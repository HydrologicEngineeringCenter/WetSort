/*
 * WetSortWin.java
 *
 * Created on November 7, 2005, 8:16 AM
 */

package wetsort;

import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.prefs.Preferences;

import hec.heclib.dss.CondensedReference;
import hec.heclib.dss.HecTimeSeries;
import hec.heclib.util.HecDouble;
import hec.heclib.util.HecDoubleArray;
import hec.heclib.util.HecTime;
import hec.heclib.util.HecTimeArray;
// Has TimeSeriesContainer
import hec.io.TimeSeriesContainer;

/**
 *
 * @author  Donald Johnons
 * 
 * Updates Dec 2018  -- Karl Tarbet
 * 
 * Version 1.0.1
 *
 *  This class program calculates the wetsort value from stage data over a user determined periods
 *
 *  The wet sort values is the maximum of the windowed minimums from the stage data. The size of the
 *  window used depends on the duration being calculated
 *
 *  The default durations are 2.5%,5%, 7.5%, 10% and 12.5%, arbitrary durations can be calculated
 *
 *  The class was extended to provide the ability to calculate additional statistics for classifying the type 
 *  of a stream based on its recorded stages and/or flows 
 */
public class WetSortWin extends javax.swing.JFrame {
    
    /** Creates a new WetSortWin */
    public WetSortWin() {
        initComponents();
        init();
        makeModeMenu();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        jFilePanel = new javax.swing.JPanel();
        jPanel10 = new javax.swing.JPanel();
        jFileRow1Panel = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        jDSSFilename = new javax.swing.JTextField();
        jPanel4 = new javax.swing.JPanel();
        jDssFileBrowseButton = new javax.swing.JButton();
        jPanel5 = new javax.swing.JPanel();
        jPanel11 = new javax.swing.JPanel();
        jFileRow2Panel = new javax.swing.JPanel();
        jPanel6 = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        jPanel7 = new javax.swing.JPanel();
        jOutputPathField = new javax.swing.JTextField();
        jPanel8 = new javax.swing.JPanel();
        jOutputPathButton = new javax.swing.JButton();
        jPanel9 = new javax.swing.JPanel();
        jPanel12 = new javax.swing.JPanel();
        jTablePanel = new javax.swing.JPanel();
        jSpacer11 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jPathTable = new javax.swing.JTable();
        jPathTable.getSelectionModel().addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent e) {
                jPathTableValueChanged(e);
            }
        });
        jSpacer12 = new javax.swing.JPanel();
        jWetSortPanel = new javax.swing.JPanel();
        jSpacer3 = new javax.swing.JPanel();
        jSeasonPanel = new javax.swing.JPanel();
        jStartTimeLabel = new javax.swing.JLabel();
        startDateInput = new wetsort.controls.DateInput();
        jStopTimeLabel = new javax.swing.JLabel();
        stopDateInput = new wetsort.controls.DateInput();
        jPanel2 = new javax.swing.JPanel();
        jSpacer4 = new javax.swing.JPanel();
        jDurationPanel = new javax.swing.JPanel();
        jStandardCheckBox = new javax.swing.JCheckBox();
        jAdditionalCheckBox = new javax.swing.JCheckBox();
        jSpacer5 = new javax.swing.JPanel();
        jStatsPanel = new javax.swing.JPanel();
        jDiffElevCheckBox = new javax.swing.JCheckBox();
        jStandardDevCheckBox = new javax.swing.JCheckBox();
        jMeanElevCheckBox = new javax.swing.JCheckBox();
        jMedianElevCheckBox = new javax.swing.JCheckBox();
        jSpacer6 = new javax.swing.JPanel();
        jOptionsPanel = new javax.swing.JPanel();
        jYearDataCBox = new javax.swing.JCheckBox();
        jSpacer7 = new javax.swing.JPanel();
        jVarStatsPanel = new javax.swing.JPanel();
        jSpacer1 = new javax.swing.JPanel();
        jjDailyStagePanel = new javax.swing.JPanel();
        jMeanStageCheckBox = new javax.swing.JCheckBox();
        jMedianStageCheckBox = new javax.swing.JCheckBox();
        jStageVarCheckBox = new javax.swing.JCheckBox();
        jStageSkewCheckBox = new javax.swing.JCheckBox();
        jRangeCheckBox = new javax.swing.JCheckBox();
        jSpreadCheckBox = new javax.swing.JCheckBox();
        jMinCheckBox = new javax.swing.JCheckBox();
        jMaxCheckBox = new javax.swing.JCheckBox();
        jjPulseStatsPanel = new javax.swing.JPanel();
        jNumHPCheckBox = new javax.swing.JCheckBox();
        jMeanHPDurCheckBox = new javax.swing.JCheckBox();
        jNumLPCheckBox = new javax.swing.JCheckBox();
        jMeanLPDurCheckBox = new javax.swing.JCheckBox();
        jRisePanel = new javax.swing.JPanel();
        jNumRisesCheckBox = new javax.swing.JCheckBox();
        jMeanRiseCheckBox = new javax.swing.JCheckBox();
        jNumFallsCheckBox = new javax.swing.JCheckBox();
        jMeanFallCheckBox = new javax.swing.JCheckBox();
        jSpacer2 = new javax.swing.JPanel();
        jBottomPanel = new javax.swing.JPanel();
        jSpacer8 = new javax.swing.JPanel();
        jYearRangePanel = new javax.swing.JPanel();
        try
        {
            yf2 = new javax.swing.text.MaskFormatter("####");
            yf2.setCommitsOnValidEdit(true);

        }
        catch (java.text.ParseException pe1)
        {
            yf2 = new javax.swing.text.MaskFormatter();
        }
        jStopYearField = new javax.swing.JFormattedTextField(yf1);
        try
        {
            yf1 = new javax.swing.text.MaskFormatter("####");
            yf1.setCommitsOnValidEdit(true);

        }
        catch (java.text.ParseException pe1)
        {
            yf1 = new javax.swing.text.MaskFormatter();
        }
        jStartYearField = new javax.swing.JFormattedTextField(yf1);
        jLabel2 = new javax.swing.JLabel();
        jSpacer9 = new javax.swing.JPanel();
        jRunButton = new javax.swing.JButton();
        jSpacer10 = new javax.swing.JPanel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jFileMenu = new javax.swing.JMenu();
        jOpenMenuItem = new javax.swing.JMenuItem();
        jMenuItem1 = new javax.swing.JMenuItem();
        JModeMenu = new javax.swing.JMenu();
        jWetSortModeItem = new javax.swing.JRadioButtonMenuItem();
        jStatsModeItem = new javax.swing.JRadioButtonMenuItem();
        jDurationMenu = new javax.swing.JMenu();
        jAddDurationMenuItem = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JSeparator();
        jDefualtDuration1Item = new javax.swing.JCheckBoxMenuItem();
        jDefualtDuration2Item = new javax.swing.JCheckBoxMenuItem();
        jDefualtDuration3Item = new javax.swing.JCheckBoxMenuItem();
        jDefualtDuration4Item = new javax.swing.JCheckBoxMenuItem();
        jDefualtDuration5Item = new javax.swing.JCheckBoxMenuItem();
        jSeparator2 = new javax.swing.JSeparator();

        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.Y_AXIS));

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Wet Sort");
        setName("WetSortFrame");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                onClose(evt);
            }
        });

        jFilePanel.setLayout(new javax.swing.BoxLayout(jFilePanel, javax.swing.BoxLayout.Y_AXIS));

        jFilePanel.setMaximumSize(new java.awt.Dimension(32767, 90));
        jFilePanel.setMinimumSize(new java.awt.Dimension(0, 90));
        jFilePanel.setPreferredSize(new java.awt.Dimension(630, 90));
        jFilePanel.add(jPanel10);

        jFileRow1Panel.setLayout(new javax.swing.BoxLayout(jFileRow1Panel, javax.swing.BoxLayout.X_AXIS));

        jPanel1.setMaximumSize(new java.awt.Dimension(10, 32767));
        jFileRow1Panel.add(jPanel1);

        jLabel1.setText("DSS File");
        jLabel1.setMaximumSize(new java.awt.Dimension(70, 21));
        jLabel1.setMinimumSize(new java.awt.Dimension(70, 21));
        jLabel1.setPreferredSize(new java.awt.Dimension(70, 21));
        jFileRow1Panel.add(jLabel1);

        jPanel3.setMaximumSize(new java.awt.Dimension(10, 32767));
        jFileRow1Panel.add(jPanel3);

        jDSSFilename.setToolTipText("The path to the DSS File");
        jDSSFilename.setMinimumSize(new java.awt.Dimension(11, 21));
        jDSSFilename.setPreferredSize(new java.awt.Dimension(11, 21));
        jFileRow1Panel.add(jDSSFilename);

        jPanel4.setMaximumSize(new java.awt.Dimension(10, 32767));
        jFileRow1Panel.add(jPanel4);

        jDssFileBrowseButton.setText("Browse ...");
        jDssFileBrowseButton.setToolTipText("Select a DSS file");
        jDssFileBrowseButton.setMaximumSize(new java.awt.Dimension(90, 23));
        jDssFileBrowseButton.setMinimumSize(new java.awt.Dimension(90, 23));
        jDssFileBrowseButton.setPreferredSize(new java.awt.Dimension(90, 23));
        jDssFileBrowseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectDSSFile(evt);
            }
        });

        jFileRow1Panel.add(jDssFileBrowseButton);

        jPanel5.setMaximumSize(new java.awt.Dimension(10, 32767));
        jFileRow1Panel.add(jPanel5);

        jFilePanel.add(jFileRow1Panel);

        jPanel11.setMaximumSize(new java.awt.Dimension(32767, 15));
        jPanel11.setMinimumSize(new java.awt.Dimension(10, 15));
        jPanel11.setPreferredSize(new java.awt.Dimension(10, 15));
        jFilePanel.add(jPanel11);

        jFileRow2Panel.setLayout(new javax.swing.BoxLayout(jFileRow2Panel, javax.swing.BoxLayout.X_AXIS));

        jFileRow2Panel.add(jPanel6);

        jLabel8.setText("Output Path");
        jLabel8.setMaximumSize(new java.awt.Dimension(70, 21));
        jLabel8.setMinimumSize(new java.awt.Dimension(70, 21));
        jLabel8.setPreferredSize(new java.awt.Dimension(70, 21));
        jFileRow2Panel.add(jLabel8);

        jFileRow2Panel.add(jPanel7);

        jFileRow2Panel.add(jOutputPathField);

        jFileRow2Panel.add(jPanel8);

        jOutputPathButton.setText("Browse ...");
        jOutputPathButton.setMaximumSize(new java.awt.Dimension(90, 23));
        jOutputPathButton.setMinimumSize(new java.awt.Dimension(90, 23));
        jOutputPathButton.setPreferredSize(new java.awt.Dimension(90, 23));
        jOutputPathButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jOutputPathButtonActionPerformed(evt);
            }
        });

        jFileRow2Panel.add(jOutputPathButton);

        jFileRow2Panel.add(jPanel9);

        jFilePanel.add(jFileRow2Panel);

        jPanel12.setMaximumSize(new java.awt.Dimension(32767, 15));
        jPanel12.setMinimumSize(new java.awt.Dimension(10, 15));
        jPanel12.setPreferredSize(new java.awt.Dimension(10, 15));
        jFilePanel.add(jPanel12);

        getContentPane().add(jFilePanel);

        jTablePanel.setLayout(new javax.swing.BoxLayout(jTablePanel, javax.swing.BoxLayout.X_AXIS));

        jTablePanel.setMinimumSize(new java.awt.Dimension(0, 0));
        jTablePanel.setPreferredSize(new java.awt.Dimension(630, 260));
        jSpacer11.setMaximumSize(new java.awt.Dimension(10, 32767));
        jSpacer11.setMinimumSize(new java.awt.Dimension(10, 260));
        jSpacer11.setPreferredSize(new java.awt.Dimension(10, 260));
        jTablePanel.add(jSpacer11);

        jScrollPane1.setPreferredSize(new java.awt.Dimension(452, 402));
        jPathTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "A Part", "B Part", "C Part", "D Part", "E Part", "F Part"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        pathTableModel = (javax.swing.table.DefaultTableModel) jPathTable.getModel();
        jScrollPane1.setViewportView(jPathTable);

        jTablePanel.add(jScrollPane1);

        jSpacer12.setMaximumSize(new java.awt.Dimension(10, 32767));
        jSpacer12.setMinimumSize(new java.awt.Dimension(10, 260));
        jSpacer12.setPreferredSize(new java.awt.Dimension(10, 260));
        jTablePanel.add(jSpacer12);

        getContentPane().add(jTablePanel);

        jWetSortPanel.setLayout(new javax.swing.BoxLayout(jWetSortPanel, javax.swing.BoxLayout.X_AXIS));

        jWetSortPanel.setMaximumSize(new java.awt.Dimension(32768, 110));
        jWetSortPanel.setMinimumSize(new java.awt.Dimension(630, 110));
        jWetSortPanel.setPreferredSize(new java.awt.Dimension(630, 0));
        jSpacer3.setMaximumSize(new java.awt.Dimension(10, 100));
        jSpacer3.setMinimumSize(new java.awt.Dimension(10, 100));
        jSpacer3.setPreferredSize(new java.awt.Dimension(10, 100));
        jWetSortPanel.add(jSpacer3);

        jSeasonPanel.setLayout(null);

        jSeasonPanel.setBorder(new javax.swing.border.TitledBorder(null, "Growing Season", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));
        jSeasonPanel.setMaximumSize(new java.awt.Dimension(32767, 100));
        jSeasonPanel.setMinimumSize(new java.awt.Dimension(190, 100));
        jSeasonPanel.setPreferredSize(new java.awt.Dimension(190, 100));
        jStartTimeLabel.setText("Start Date");
        jSeasonPanel.add(jStartTimeLabel);
        jStartTimeLabel.setBounds(10, 20, 60, 30);

        jSeasonPanel.add(startDateInput);
        startDateInput.setBounds(70, 20, 110, 30);

        jStopTimeLabel.setText("Stop Date");
        jSeasonPanel.add(jStopTimeLabel);
        jStopTimeLabel.setBounds(10, 60, 60, 30);

        jSeasonPanel.add(stopDateInput);
        stopDateInput.setBounds(68, 60, 110, 30);

        jSeasonPanel.add(jPanel2);
        jPanel2.setBounds(10, 100, 10, 10);

        jWetSortPanel.add(jSeasonPanel);

        jSpacer4.setMaximumSize(new java.awt.Dimension(10, 100));
        jSpacer4.setMinimumSize(new java.awt.Dimension(10, 100));
        jSpacer4.setPreferredSize(new java.awt.Dimension(10, 100));
        jWetSortPanel.add(jSpacer4);

        jDurationPanel.setLayout(null);

        jDurationPanel.setBorder(new javax.swing.border.TitledBorder(null, "Duration", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));
        jDurationPanel.setMaximumSize(new java.awt.Dimension(32767, 100));
        jDurationPanel.setMinimumSize(new java.awt.Dimension(120, 100));
        jDurationPanel.setPreferredSize(new java.awt.Dimension(120, 100));
        jStandardCheckBox.setSelected(true);
        jStandardCheckBox.setText("Standard");
        jStandardCheckBox.setToolTipText("Run for the durations of 2.5%, 5%, 7.5%, 10%, and 12.5%");
        jStandardCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jStandardCheckBoxActionPerformed(evt);
            }
        });

        jDurationPanel.add(jStandardCheckBox);
        jStandardCheckBox.setBounds(10, 20, 100, 23);

        jAdditionalCheckBox.setText("Additional");
        jAdditionalCheckBox.setToolTipText("Run user defined durations");
        jAdditionalCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jAdditionalCheckBoxActionPerformed(evt);
            }
        });

        jDurationPanel.add(jAdditionalCheckBox);
        jAdditionalCheckBox.setBounds(10, 50, 100, 23);

        jWetSortPanel.add(jDurationPanel);

        jSpacer5.setMaximumSize(new java.awt.Dimension(10, 100));
        jSpacer5.setMinimumSize(new java.awt.Dimension(10, 100));
        jSpacer5.setPreferredSize(new java.awt.Dimension(10, 100));
        jWetSortPanel.add(jSpacer5);

        jStatsPanel.setLayout(null);

        jStatsPanel.setBorder(new javax.swing.border.TitledBorder(null, "Stats", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));
        jStatsPanel.setMaximumSize(new java.awt.Dimension(32767, 100));
        jStatsPanel.setMinimumSize(new java.awt.Dimension(150, 100));
        jStatsPanel.setPreferredSize(new java.awt.Dimension(150, 100));
        jDiffElevCheckBox.setSelected(true);
        jDiffElevCheckBox.setText("diff");
        jDiffElevCheckBox.setToolTipText("Record the differance between the max min and the max of that period");
        jStatsPanel.add(jDiffElevCheckBox);
        jDiffElevCheckBox.setBounds(80, 60, 60, 23);

        jStandardDevCheckBox.setSelected(true);
        jStandardDevCheckBox.setText("std");
        jStandardDevCheckBox.setToolTipText("Record the standard deviation of the elevation for the duration");
        jStatsPanel.add(jStandardDevCheckBox);
        jStandardDevCheckBox.setBounds(10, 60, 60, 23);

        jMeanElevCheckBox.setSelected(true);
        jMeanElevCheckBox.setText("mean");
        jMeanElevCheckBox.setToolTipText("Record the mean elevation for the duration");
        jStatsPanel.add(jMeanElevCheckBox);
        jMeanElevCheckBox.setBounds(80, 20, 60, 23);

        jMedianElevCheckBox.setSelected(true);
        jMedianElevCheckBox.setText("median");
        jStatsPanel.add(jMedianElevCheckBox);
        jMedianElevCheckBox.setBounds(10, 20, 70, 23);

        jWetSortPanel.add(jStatsPanel);

        jSpacer6.setMaximumSize(new java.awt.Dimension(10, 100));
        jSpacer6.setMinimumSize(new java.awt.Dimension(10, 100));
        jSpacer6.setPreferredSize(new java.awt.Dimension(10, 100));
        jWetSortPanel.add(jSpacer6);

        jOptionsPanel.setLayout(null);

        jOptionsPanel.setBorder(new javax.swing.border.TitledBorder(null, "Options", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));
        jOptionsPanel.setMaximumSize(new java.awt.Dimension(32767, 100));
        jOptionsPanel.setMinimumSize(new java.awt.Dimension(120, 100));
        jOptionsPanel.setPreferredSize(new java.awt.Dimension(120, 100));
        jYearDataCBox.setSelected(true);
        jYearDataCBox.setText("Year Data");
        jYearDataCBox.setToolTipText("Display the first day of the medians period");
        jOptionsPanel.add(jYearDataCBox);
        jYearDataCBox.setBounds(10, 20, 100, 23);

        jWetSortPanel.add(jOptionsPanel);

        jSpacer7.setMaximumSize(new java.awt.Dimension(10, 100));
        jSpacer7.setMinimumSize(new java.awt.Dimension(10, 100));
        jSpacer7.setPreferredSize(new java.awt.Dimension(10, 100));
        jWetSortPanel.add(jSpacer7);

        getContentPane().add(jWetSortPanel);

        jVarStatsPanel.setLayout(new javax.swing.BoxLayout(jVarStatsPanel, javax.swing.BoxLayout.X_AXIS));

        jVarStatsPanel.setMaximumSize(new java.awt.Dimension(32767, 110));
        jVarStatsPanel.setPreferredSize(new java.awt.Dimension(630, 110));
        jSpacer1.setMaximumSize(new java.awt.Dimension(10, 100));
        jSpacer1.setMinimumSize(new java.awt.Dimension(10, 100));
        jSpacer1.setPreferredSize(new java.awt.Dimension(10, 100));
        jVarStatsPanel.add(jSpacer1);

        jjDailyStagePanel.setLayout(null);

        jjDailyStagePanel.setBorder(new javax.swing.border.TitledBorder(null, "Daily Stage", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));
        jjDailyStagePanel.setMaximumSize(new java.awt.Dimension(32767, 100));
        jjDailyStagePanel.setPreferredSize(new java.awt.Dimension(280, 100));
        jMeanStageCheckBox.setSelected(true);
        jMeanStageCheckBox.setText("Mean");
        jMeanStageCheckBox.setToolTipText("Record the daily mean stage");
        jjDailyStagePanel.add(jMeanStageCheckBox);
        jMeanStageCheckBox.setBounds(10, 20, 70, 23);

        jMedianStageCheckBox.setSelected(true);
        jMedianStageCheckBox.setText("Median");
        jMedianStageCheckBox.setToolTipText("Record the daily Median Stage");
        jjDailyStagePanel.add(jMedianStageCheckBox);
        jMedianStageCheckBox.setBounds(10, 60, 70, 23);

        jStageVarCheckBox.setSelected(true);
        jStageVarCheckBox.setText("Var");
        jStageVarCheckBox.setToolTipText("Record the Daily stage Variance");
        jjDailyStagePanel.add(jStageVarCheckBox);
        jStageVarCheckBox.setBounds(80, 20, 70, 23);

        jStageSkewCheckBox.setSelected(true);
        jStageSkewCheckBox.setText("Skew");
        jStageSkewCheckBox.setToolTipText("Record the skew of the daily stages");
        jjDailyStagePanel.add(jStageSkewCheckBox);
        jStageSkewCheckBox.setBounds(80, 60, 60, 23);

        jRangeCheckBox.setSelected(true);
        jRangeCheckBox.setText("Range");
        jjDailyStagePanel.add(jRangeCheckBox);
        jRangeCheckBox.setBounds(150, 20, 70, 23);

        jSpreadCheckBox.setSelected(true);
        jSpreadCheckBox.setText("Spread");
        jjDailyStagePanel.add(jSpreadCheckBox);
        jSpreadCheckBox.setBounds(150, 60, 70, 23);

        jMinCheckBox.setSelected(true);
        jMinCheckBox.setText("Min");
        jjDailyStagePanel.add(jMinCheckBox);
        jMinCheckBox.setBounds(220, 20, 50, 23);

        jMaxCheckBox.setSelected(true);
        jMaxCheckBox.setText("Max");
        jjDailyStagePanel.add(jMaxCheckBox);
        jMaxCheckBox.setBounds(220, 60, 50, 23);

        jVarStatsPanel.add(jjDailyStagePanel);

        jjPulseStatsPanel.setLayout(null);

        jjPulseStatsPanel.setBorder(new javax.swing.border.TitledBorder(null, "Pulses", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));
        jjPulseStatsPanel.setMaximumSize(new java.awt.Dimension(32767, 100));
        jjPulseStatsPanel.setMinimumSize(new java.awt.Dimension(140, 100));
        jjPulseStatsPanel.setPreferredSize(new java.awt.Dimension(140, 100));
        jNumHPCheckBox.setSelected(true);
        jNumHPCheckBox.setText("NHP");
        jNumHPCheckBox.setToolTipText("The Number of HIgh Pulses");
        jjPulseStatsPanel.add(jNumHPCheckBox);
        jNumHPCheckBox.setBounds(10, 20, 60, 23);

        jMeanHPDurCheckBox.setSelected(true);
        jMeanHPDurCheckBox.setText("MHPD");
        jMeanHPDurCheckBox.setToolTipText("Mean High Pulse Duration");
        jjPulseStatsPanel.add(jMeanHPDurCheckBox);
        jMeanHPDurCheckBox.setBounds(70, 20, 60, 23);

        jNumLPCheckBox.setSelected(true);
        jNumLPCheckBox.setText("NLP");
        jNumLPCheckBox.setToolTipText("The Number of Low Pulses");
        jjPulseStatsPanel.add(jNumLPCheckBox);
        jNumLPCheckBox.setBounds(10, 60, 60, 23);

        jMeanLPDurCheckBox.setSelected(true);
        jMeanLPDurCheckBox.setText("MLPD");
        jMeanLPDurCheckBox.setToolTipText("Mean Low Pulse Duration");
        jjPulseStatsPanel.add(jMeanLPDurCheckBox);
        jMeanLPDurCheckBox.setBounds(70, 60, 60, 23);

        jVarStatsPanel.add(jjPulseStatsPanel);

        jRisePanel.setLayout(null);

        jRisePanel.setBorder(new javax.swing.border.TitledBorder(null, "Rise & Fall", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));
        jRisePanel.setMaximumSize(new java.awt.Dimension(32767, 100));
        jRisePanel.setOpaque(false);
        jRisePanel.setPreferredSize(new java.awt.Dimension(190, 100));
        jNumRisesCheckBox.setSelected(true);
        jNumRisesCheckBox.setText("Num Rises");
        jNumRisesCheckBox.setToolTipText("The number of days of rissing stages");
        jRisePanel.add(jNumRisesCheckBox);
        jNumRisesCheckBox.setBounds(10, 20, 90, 23);

        jMeanRiseCheckBox.setSelected(true);
        jMeanRiseCheckBox.setText("Mean Rise");
        jMeanRiseCheckBox.setToolTipText("The average amount of a daily rise");
        jRisePanel.add(jMeanRiseCheckBox);
        jMeanRiseCheckBox.setBounds(10, 60, 90, 23);

        jNumFallsCheckBox.setSelected(true);
        jNumFallsCheckBox.setText("Num Falls");
        jNumFallsCheckBox.setToolTipText("The Number of days with falling stages");
        jRisePanel.add(jNumFallsCheckBox);
        jNumFallsCheckBox.setBounds(100, 20, 80, 23);

        jMeanFallCheckBox.setSelected(true);
        jMeanFallCheckBox.setText("Mean Fall");
        jMeanFallCheckBox.setToolTipText("The average amount of a daily fall");
        jRisePanel.add(jMeanFallCheckBox);
        jMeanFallCheckBox.setBounds(100, 60, 80, 23);

        jVarStatsPanel.add(jRisePanel);

        jSpacer2.setMaximumSize(new java.awt.Dimension(10, 100));
        jSpacer2.setMinimumSize(new java.awt.Dimension(10, 100));
        jSpacer2.setPreferredSize(new java.awt.Dimension(10, 100));
        jVarStatsPanel.add(jSpacer2);

        getContentPane().add(jVarStatsPanel);

        jBottomPanel.setLayout(new javax.swing.BoxLayout(jBottomPanel, javax.swing.BoxLayout.X_AXIS));

        jBottomPanel.setFocusTraversalPolicyProvider(true);
        jBottomPanel.setMaximumSize(new java.awt.Dimension(32767, 60));
        jBottomPanel.setPreferredSize(new java.awt.Dimension(630, 60));
        jSpacer8.setMaximumSize(new java.awt.Dimension(10, 50));
        jSpacer8.setMinimumSize(new java.awt.Dimension(10, 50));
        jSpacer8.setPreferredSize(new java.awt.Dimension(10, 50));
        jBottomPanel.add(jSpacer8);

        jYearRangePanel.setLayout(null);

        jYearRangePanel.setBorder(new javax.swing.border.TitledBorder(null, "Years", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));
        jYearRangePanel.setMaximumSize(new java.awt.Dimension(180, 50));
        jYearRangePanel.setMinimumSize(new java.awt.Dimension(180, 50));
        jYearRangePanel.setPreferredSize(new java.awt.Dimension(180, 50));
        jYearRangePanel.add(jStopYearField);
        jStopYearField.setBounds(110, 20, 60, 19);

        jYearRangePanel.add(jStartYearField);
        jStartYearField.setBounds(10, 20, 60, 19);

        jLabel2.setText("to");
        jYearRangePanel.add(jLabel2);
        jLabel2.setBounds(80, 20, 20, 20);

        jBottomPanel.add(jYearRangePanel);

        jSpacer9.setMaximumSize(new java.awt.Dimension(32767, 50));
        jSpacer9.setMinimumSize(new java.awt.Dimension(10, 60));
        jSpacer9.setPreferredSize(new java.awt.Dimension(10, 60));
        jBottomPanel.add(jSpacer9);

        jRunButton.setText("Run");
        jRunButton.setToolTipText("");
        jRunButton.setEnabled(false);
        jRunButton.setMaximumSize(new java.awt.Dimension(90, 20));
        jRunButton.setMinimumSize(new java.awt.Dimension(90, 20));
        jRunButton.setPreferredSize(new java.awt.Dimension(90, 20));
        jRunButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRunButtonActionPerformed(evt);
            }
        });

        jBottomPanel.add(jRunButton);

        jSpacer10.setMaximumSize(new java.awt.Dimension(20, 50));
        jSpacer10.setMinimumSize(new java.awt.Dimension(20, 50));
        jSpacer10.setPreferredSize(new java.awt.Dimension(20, 50));
        jBottomPanel.add(jSpacer10);

        getContentPane().add(jBottomPanel);

        jFileMenu.setMnemonic('f');
        jFileMenu.setText("File");
        jOpenMenuItem.setMnemonic('o');
        jOpenMenuItem.setText("Open...");
        jOpenMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectDSSFile(evt);
            }
        });

        jFileMenu.add(jOpenMenuItem);

        jMenuItem1.setMnemonic('x');
        jMenuItem1.setText("Exit");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });

        jFileMenu.add(jMenuItem1);

        jMenuBar1.add(jFileMenu);

        JModeMenu.setMnemonic('o');
        JModeMenu.setText("Mode");
        jWetSortModeItem.setText("Wet Sort");
        jWetSortModeItem.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                jWetSortModeItemItemStateChanged(evt);
            }
        });

        JModeMenu.add(jWetSortModeItem);

        jStatsModeItem.setText("Stats");
        jStatsModeItem.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                jStatsModeItemItemStateChanged(evt);
            }
        });

        JModeMenu.add(jStatsModeItem);

        jMenuBar1.add(JModeMenu);

        jDurationMenu.setText("Duration");
        jAddDurationMenuItem.setText("Add Duration...");
        jAddDurationMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jAddDurationMenuItemActionPerformed(evt);
            }
        });

        jDurationMenu.add(jAddDurationMenuItem);

        jDurationMenu.add(jSeparator1);

        jDefualtDuration1Item.setText("2.5%");
        jDurationMenu.add(jDefualtDuration1Item);

        jDefualtDuration2Item.setText("5.0%");
        jDurationMenu.add(jDefualtDuration2Item);

        jDefualtDuration3Item.setText("7.5%");
        jDurationMenu.add(jDefualtDuration3Item);

        jDefualtDuration4Item.setText("10.0%");
        jDurationMenu.add(jDefualtDuration4Item);

        jDefualtDuration5Item.setText("12.5%");
        jDurationMenu.add(jDefualtDuration5Item);

        jDurationMenu.add(jSeparator2);

        jMenuBar1.add(jDurationMenu);

        setJMenuBar(jMenuBar1);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-640)/2, (screenSize.height-580)/2, 640, 580);
    }//GEN-END:initComponents
    
    /** This function is called when the state of the stats menu item changes */
    
    private void jStatsModeItemItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_jStatsModeItemItemStateChanged
        // if the state change was a selection change mode
        
        if ( evt.getStateChange() == java.awt.event.ItemEvent.SELECTED )
        {
            statsMode();
        }
    }//GEN-LAST:event_jStatsModeItemItemStateChanged
    
    /** This function is called when the state of the wet sort menu item changes */
    
    private void jWetSortModeItemItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_jWetSortModeItemItemStateChanged
        // if the state change was a selection change mode
        
        if ( evt.getStateChange() == java.awt.event.ItemEvent.SELECTED )
        {
            wetSortMode();
        }
    }//GEN-LAST:event_jWetSortModeItemItemStateChanged
    
    /**  Change the displayed GUI to show the controls used for wetsort */
    
    private void wetSortMode()
    {
        jWetSortPanel.setVisible(true);
        jWetSortPanel.setPreferredSize(new java.awt.Dimension(0,110));
        
        jVarStatsPanel.setVisible(false);
        jVarStatsPanel.setPreferredSize(new java.awt.Dimension(0,0));
        
        jDurationMenu.setVisible(true);
        mode = WETSORT;
    }
    
    /** Change the displayed GUI to show the controls used for stats */
    
    private void statsMode()
    {
         jWetSortPanel.setVisible(false);
         jWetSortPanel.setPreferredSize(new java.awt.Dimension(0,0));
         
         
         jVarStatsPanel.setVisible(true);
         jVarStatsPanel.setPreferredSize(new java.awt.Dimension(0,110));        
         
         jDurationMenu.setVisible(false);
         mode = VARSTATS;
    }
    
    /** This function links the state menu items to a buttongroup so that
     * only one may be selected at a time */
    
    private void makeModeMenu()
    {
        javax.swing.ButtonGroup bg = new javax.swing.ButtonGroup();
        
        bg.add(jWetSortModeItem);
        bg.add(jStatsModeItem);
        
        // The inital mode is wetSort
        jWetSortModeItem.setSelected(true);
    }
    
    /** This function prompts the user for a value for a custom duration and then adds
     *  and item with the value to the duration menu */
    
    private void jAddDurationMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAddDurationMenuItemActionPerformed
        
        // shwo the sepearator between the 
        if ( jSeparator2.isVisible() == false )
        {
            jSeparator2.setVisible(true);
        }
        
        // show the duration dialog
        durationDialog.setVisible(true);
        
        // if a new duration was entered in the dialog
        if ( durationDialog.canceled() == false )
        {
            double val = durationDialog.value();
            
            // make a new menu item with the entered duration
            javax.swing.JCheckBoxMenuItem newItem = new javax.swing.JCheckBoxMenuItem();
            newItem.setSelected(true);
            newItem.setText(Double.toString(val));
            
            // add the item to the menu and the container of custom durations
            customDuration.add(newItem);
            
            jDurationMenu.add(newItem);
        }
    }//GEN-LAST:event_jAddDurationMenuItemActionPerformed

    private void jStandardCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jStandardCheckBoxActionPerformed
        boolean b = jStandardCheckBox.isSelected();
        
        // select the default durations
        
        jDefualtDuration1Item.setSelected(b);
        jDefualtDuration2Item.setSelected(b);
        jDefualtDuration3Item.setSelected(b);
        jDefualtDuration4Item.setSelected(b);
        jDefualtDuration5Item.setSelected(b);
        
    }//GEN-LAST:event_jStandardCheckBoxActionPerformed

    private void jAdditionalCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAdditionalCheckBoxActionPerformed
        boolean state = jAdditionalCheckBox.isSelected();
        
        jAddDurationMenuItem.setVisible(state);
        jSeparator1.setVisible(state);
        
        if ( state == false )
        {
            clearAdditionalDurations();
        }
    }//GEN-LAST:event_jAdditionalCheckBoxActionPerformed

    /** This is the function of the quit item. Terminiate the program */
    
    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        java.lang.System.exit(0);
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    /** Prompt the user to select an output directory */
    
    private void jOutputPathButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jOutputPathButtonActionPerformed
        javax.swing.JFileChooser  fc;
        fc = new javax.swing.JFileChooser ();                          // make the file chooser
        fc.setFileSelectionMode(fc.DIRECTORIES_ONLY);                 // display directores only
        fc.setCurrentDirectory(new java.io.File(outputDirPath)) ;     // open the last directory
        int rval = fc.showOpenDialog(this);
        
        if ( rval == fc.CANCEL_OPTION )
        {
            return;
        }
        else if ( rval == fc.APPROVE_OPTION )
        {
            outputDirPath = fc.getSelectedFile().getPath();
            jOutputPathField.setText(outputDirPath);
            
            prefs.put("Output Path",outputDirPath);
        }

              
        
    }//GEN-LAST:event_jOutputPathButtonActionPerformed

    /** This function is called when the main window closes. */
    
    private void onClose(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_onClose
       updatePrefs();
    }//GEN-LAST:event_onClose

    /** Respond to the run button being presses */
    
    private void jRunButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRunButtonActionPerformed
            
        /* read the gui then process the selected data */
        
        for( int i = 0; i < selectedPaths.size(); ++i)
        {
            currentPath = selectedPaths.get(i);
            
            switch(mode)
            {
                case WETSORT:
                    wsReadGUI();
                    wsRunPath();
                break;

                case VARSTATS:
                    vsReadGUI();
                    vsRunPath();
                break;
            }
        }
    }//GEN-LAST:event_jRunButtonActionPerformed

    /** Display a dialog that allows the user to select a DSS file */
    
    private void selectDSSFile(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectDSSFile
      javax.swing.JFileChooser  fc;
        
        if ( evt.getSource() == jDssFileBrowseButton || evt.getSource() == jOpenMenuItem)
        {
            fc = new javax.swing.JFileChooser ();               // make the file chooser
            fc.setFileSelectionMode(fc.FILES_ONLY); // display files only
            fc.setCurrentDirectory(lastFile);       // open the last directory
            fc.setAcceptAllFileFilterUsed(false);   // do not display all files
            
            // set the file filter to return only DSS files
            
            fc.setFileFilter(new javax.swing.filechooser.FileFilter(){ 
                public boolean accept(java.io.File f)
                {
                    String ext = getExtension(f);
                    
                    if ( f.isDirectory() )
                        return true;
                    else if ( ext == null)
                    {
                        return false;
                    }
                    else if ( ext.equals("dss"))
                        return true;
                    else
                        return false;
                }
                
                public String getDescription()
                {
                    return new String("DSS File filter");
                }
                
                private String getExtension(java.io.File f) {
                String ext = null;
                String s = f.getName();
                int i = s.lastIndexOf('.');

                if (i > 0 &&  i < s.length() - 1) {
                  ext = s.substring(i+1).toLowerCase();
                }
                return ext;
    }                
            });
            int rval;
            rval = fc.showOpenDialog(this);       // show the dialog
            if ( rval == fc.CANCEL_OPTION )
            {
                return;
            }
            else if ( rval == fc.APPROVE_OPTION)
            {       
                lastFile = fc.getSelectedFile();
                fileLoaded = true;
                jDSSFilename.setText( lastFile.getAbsolutePath());
                
                prefs.put("Last DSS File Opened",lastFile.getAbsolutePath());
                loadDSSFile();
            }
            else
            {
                // some error occured 
            }

            
        }
    }//GEN-LAST:event_selectDSSFile
   
    /**
     * Load the user selected DSS file 
     */
    
    public void loadDSSFile()
    {
        // close the old time series if one exists
    	pathTableModel.setRowCount(0);
        
        // make a new time series
    	HecTimeSeries ts = new HecTimeSeries();
          
        // open the interfaces to the dss file
        ts.setDSSFileName(lastFile.getAbsolutePath(),true);
        
        
        CondensedReference[] cr = ts.getCondensedCatalog("");
        
        for (int i = 0; i < cr.length; i++) {      
        	CondensedReference r =cr[i];    // /30330/LITTLETALLA-BATESVILLE/FLOW/01JAN1906/IR-YEAR/CALC/
        	if(r.getNominalPathname().toLowerCase().indexOf("1day") >0  )
        	   pathTableModel.addRow(r.toString().substring(1).split("/"));
		}
                
        closeDSSFile(ts);
        jPathTable.clearSelection();
        
        if ( jPathTable.getRowCount() > 0)
        {
            jPathTable.addRowSelectionInterval(0,0);
        }
    }
    
    /** Close the the file pointed to by the Timeseries Reference and set it to null */
    
    private void closeDSSFile(HecTimeSeries ts)
    {       
        if ( ts != null )
        {
            // tell the dss library that io with this file is done
            ts.done();
        
            //c lose the file
            ts.close();
        
            // remove the reference
            ts = null;
        }
        
        // clear the path display list
        //pathTableModel.setRowCount(0);
    }
    
    /**  Initalize the program variables and the GUI */
    
    private void init()
    {
        lastFile = null;
        fileLoaded = false;
        
        prefs = Preferences.userNodeForPackage(WetSortWin.class);
        
        // Get the last file opened   
        String tmp = prefs.get("Last DSS File Opened","");
        if ( tmp.equals("") == false)
        {
            lastFile = new java.io.File(tmp);
        }
        
        // read the preferences
        outputDirPath = prefs.get("Output Dir","");
        
        seasonStartMonth = prefs.getInt("Season Start Month",3);
        seasonStartDay = prefs.getInt("Season Start Day",1);
        seasonStopMonth = prefs.getInt("Season Stop Month",11);
        seasonStopDay = prefs.getInt("Season Stop Day",27);
        showYearData = prefs.getBoolean("Show Year Data", true);
        
        // initalize GUI elements
        jOutputPathField.setText(outputDirPath);
        jYearDataCBox.setSelected(showYearData);

        // set the start date
        startDateInput.setDay(seasonStartDay);
        startDateInput.setMonth(seasonStartMonth);
        
        // set the stop date
        stopDateInput.setDay(seasonStopDay);
        stopDateInput.setMonth(seasonStopMonth);
        
        // set the selection of the default durations
        jStandardCheckBox.setSelected(true);
        jDefualtDuration1Item.setSelected(true);
        jDefualtDuration2Item.setSelected(true);
        jDefualtDuration3Item.setSelected(true);
        jDefualtDuration4Item.setSelected(true);
        jDefualtDuration5Item.setSelected(true);        
        
        // hide the menu item for adding durations
        jAddDurationMenuItem.setVisible(false);
        jSeparator1.setVisible(false);
        jSeparator2.setVisible(false);
        
        durations = new ArrayList<Double>();
        duration_length = new ArrayList<Long>();
        
        median_val = new ArrayList<HecDouble>();
        mean_val = new ArrayList<HecDouble>();
        std_val = new ArrayList<HecDouble>();
        diff_val = new ArrayList<HecDouble>();
        
        customDuration = new ArrayList<javax.swing.JMenuItem>();
        
        durationDialog = new CustomDurationDialog(this,true);
        
        selectedPaths = new ArrayList<String>();
        
        jPathTable.getSelectionModel().setSelectionMode(javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        jPathTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
    }
    
    /** Reset the preferences to the default values */
    
    private void resetPrefs()
    {
        prefs.put("Last DSS File Opened","");
        
        prefs.put("Output Dir","");
        
        prefs.putInt("Season Start Month",3);
        prefs.putInt("Season Start Day",1);
        prefs.putInt("Season Stop Month",11);
        prefs.putInt("Season Stop Day",27);
        prefs.put("Output Path","");
        
    }
    
    /** Respond to the selection of a DSS Path */
    
    private void jPathTableValueChanged(javax.swing.event.ListSelectionEvent e)
    {
        // wait for the new value
        if (e.getValueIsAdjusting()) return;
        
        javax.swing.ListSelectionModel lsm =
            (javax.swing.ListSelectionModel)e.getSource();
        
        if ( lsm.isSelectionEmpty() )
        {
            jRunButton.setEnabled(false);            
            return;
        }
        
        // get the current selection from the list
        currentIndex = lsm.getMinSelectionIndex();
        
        String path;
        int startYear = 0;
        int stopYear = 0;
        boolean selectionFound = false;
        
        selectedPaths.clear();
      
        for( int i = 0; i < pathTableModel.getRowCount(); ++i )
        {
            if ( lsm.isSelectedIndex(i))
            {
                String[] s = ( (String) pathTableModel.getValueAt(i, 3) ).split(" - ");

                // construct the current DSS path
                path = "/";
                path += (String) pathTableModel.getValueAt(i, 0);
                path += "/";
                path += (String) pathTableModel.getValueAt(i, 1);
                path += "/";
                path += (String) pathTableModel.getValueAt(i, 2);
                path += "/";       
                path +=  s[0];
                path += "/";
                path += (String) pathTableModel.getValueAt(i, 4);
                path += "/";
                path += (String) pathTableModel.getValueAt(i, 5);
                
                selectedPaths.add(path);
                
                int l, val;
                if ( selectionFound == false )
                {
                    selectionFound = true;
                    l = s[0].length();
                    startYear = Integer.parseInt(s[0].substring(l-4));
                    l = s[1].length();
                    stopYear = Integer.parseInt(s[1].substring(l-4));
                }
                else
                {
                    l = s[0].length();
                    val = Integer.parseInt(s[0].substring(l-4));
                    if ( val > startYear )
                    {
                        startYear = val;
                    }
                    
                    l = s[1].length();
                    val = Integer.parseInt(s[1].substring(l-4));
                    if ( val < stopYear ) 
                    { 
                        stopYear = val;
                    }   
                }
            }
        }
        
        jStartYearField.setText(Integer.toString(startYear));
        jStopYearField.setText(Integer.toString(stopYear));
        
        //enable the run button
        jRunButton.setEnabled(true);
    }
    
    /** Read the control values for wetsort form the GUI */
    
    private void wsReadGUI()
    {
        updatePrefs();
        
        // check what to record
        calcDiff = jDiffElevCheckBox.isSelected();
        calcStd = jStandardDevCheckBox.isSelected();
        calcMean = jMeanElevCheckBox.isSelected();
        calcMedian = jMedianElevCheckBox.isSelected();
        
        windowStart = startDateInput.getDayString();
        windowStart += startDateInput.getMonthString();
 
        windowStop = stopDateInput.getDayString();
        windowStop += stopDateInput.getMonthString();        

        startYear = jStartYearField.getText();
        stopYear = jStopYearField.getText();       
        
        // clear the durations list
        durations.clear();
        
        // add the standard durations
        if ( jDefualtDuration1Item.isSelected() )
        {
            durations.add(new Double(0.025));
        }
        
        if ( jDefualtDuration2Item.isSelected() )
        {
            durations.add(new Double(0.05));
        }
        
        if ( jDefualtDuration3Item.isSelected() )
        {
            durations.add(new Double(0.075));
        }
        
         if ( jDefualtDuration4Item.isSelected() )
        {
            durations.add(new Double(0.10));
        }
        
        if ( jDefualtDuration5Item.isSelected() )
        {
            durations.add(new Double(0.125));
        }
        
        // add additional durations
        
        for( int i = 0; i < customDuration.size(); ++i )
        {
            if ( customDuration.get(i).isSelected() )
            {
                double d = Double.parseDouble(customDuration.get(i).getText());
                durations.add(new Double(d*.01));
            }
        }
        
        java.util.Collections.sort(durations);
    }
    
    /** Save the current settings */
    
    private void updatePrefs()
    {
        seasonStartDay = startDateInput.getDayInt();
        seasonStartMonth = startDateInput.getMonthInt();
        seasonStopDay = stopDateInput.getDayInt();
        seasonStopMonth = stopDateInput.getMonthInt();
        outputDirPath = jOutputPathField.getText();
        showYearData = jYearDataCBox.isSelected();
        
        prefs.putInt("Season Start Month",seasonStartMonth);
        prefs.putInt("Season Start Day",seasonStartDay);
        prefs.putInt("Season Stop Month",seasonStopMonth);
        prefs.putInt("Season Stop Day",seasonStopDay);
        prefs.put("Output Dir",outputDirPath);
        prefs.putBoolean("Show Year Data", showYearData);
    }
    
    /** Calculate the wetsort value for the data in the selected DSS path */
    
    private void wsRunPath()
    { 
        int start = Integer.parseInt(startYear);
        int stop = Integer.parseInt(stopYear);
        
        // initialize the main data structures
        
        // determine the number of years that will be run
        numYears = stop - start + 1;
        
        data = new ArrayList< ArrayList<YearData> >(durations.size());

        for( int i = 0; i < durations.size(); ++i )
        {
            data.add(new ArrayList<YearData>(numYears));              
        }        
        

        HecTimeSeries ts = new HecTimeSeries();
        ts.setDSSFileName(lastFile.getAbsolutePath());
        for( int i = 0; i < numYears; ++i )
        {
            String s1 = windowStart + Integer.toString(start + i);
            String s2 = windowStop + Integer.toString(start + i);
            
            startTime = new HecTime(s1);
            stopTime = new HecTime(s2);
            
            if ( startTime.julian() > stopTime.julian() )
            {
            	System.out.println("Error with Date Range");
                s2 = windowStop + Integer.toString(i+1);
                stopTime = new HecTime(s2);
            }
            
            if ( i == 0 )
            {
                // determine the number of days for each durations   
                wsCalcDurationDays();              
            }
			System.out.println("path:"+currentPath);
			TimeSeriesContainer c = new TimeSeriesContainer();
            c.fullName = currentPath;
           
            c.endTime = stopTime.value();
            c.startTime = startTime.value();
                  
            
          int status = ts.read(c, true);
          if( status != 0)
          {
        	  System.out.println("Error: ts.read "+status);
        	  continue;
          }
          values = new HecDoubleArray(c.values);
          days = new HecTimeArray(c.times);
          
            
            wsCalcYearStats(i);
        }
        
        wsCalcSummaryStats();
        wsWriteTable();
    }
    
    /** Calculate the number of days in each duration */
    
    private void wsCalcDurationDays()
    {
       duration_length.clear();
       
       int numDays = startTime.computeNumberIntervals(stopTime, 1440);
       
       double val;
       
       for( int i = 0 ; i < durations.size(); ++i )
       {
           val = durations.get(i) * numDays;
           duration_length.add(i,java.lang.Math.round(val) );
       }
    }
    
    /** Calculate the wet sort value for one year of data */
    
    private void wsCalcYearStats(int yearIndex)
    {
            
        for( int i = 0; i < durations.size(); ++i )
        {
            wsCalcDurationStats(yearIndex,i);
        } 
        
    }
    
    /** Calculate the wetsort value for the indicated duration */
    
    private void wsCalcDurationStats(int yearPos, int durPos)
    {   
        // get the number of days 
        int numDays = duration_length.get(durPos).intValue();
        
        // find out how many windows there are
        int len = values.numberElements() - numDays + 1;
        
        HecDouble currentVal = new HecDouble();
        HecDouble currentDiff = new HecDouble();
        HecTime currentDate = new HecTime();
        
        HecDouble minVal = new HecDouble();
        HecDouble diffVal = new HecDouble();
        
        // set the initial values with the first window
        wsCalcWindowMinDiff(0,numDays,currentVal,currentDiff);
        currentDate = days.element(0);
        
        for( int i = 1; i < len; ++i )
        {
            wsCalcWindowMinDiff(i,numDays,minVal,diffVal);
            if ( minVal.greaterThan(currentVal) )
            {
                currentVal.set(minVal);
                currentDiff.set(diffVal);
                currentDate.set(days.element(i));
            }
        }
        
        data.get(durPos).add(yearPos, new YearData(currentVal,currentDiff,currentDate));

       
    }
    
    /** Find the minimum value in a window of data and the difference between the windows min and max */
    
    private void wsCalcWindowMinDiff(int startPos, int windowSize, HecDouble minVal, HecDouble diff)
    {
        diff.set(values.element(startPos).value());
        minVal.set(values.element(startPos).value());
        
        HecDouble max = diff;
        
        for( int i = 1; i < windowSize; ++i  )
        {
            HecDouble val = values.element(startPos+i);
            
            if ( val.lessThan(minVal) )
            {
                minVal.set(val);    
            }
            
            if ( val.greaterThan(max) )
            {
                max.set(val);
            }
        }
        
        // calculate the difference not max is an alias of diff and diff will now have the correct value
        max.subtract(minVal); 
        
        
    }
    
    /** Calculate summary statistics from the yearly wetsort data */
    
    void wsCalcSummaryStats()
    {
        median_val.clear();
        mean_val.clear();
        diff_val.clear();
        std_val.clear();
        
        for( int i = 0; i < data.size(); ++i )
        {
            // sort the list 
            java.util.Collections.sort(data.get(i),new java.util.Comparator<YearData>()
            {
                public int compare(YearData d1, YearData d2)
                {
                    double val1 = d1.value();
                    double val2 = d2.value();
                    
                    if ( val1 < val2 )
                    {
                        return -1;
                    }
                    else if ( val1 > val2 )
                    {
                        return 1;
                    }
                    else
                    {
                        return 0;
                    }
                }
                   
            });
            
            // get the median value
            
            int pos = data.get(i).size() / 2;
            if ( data.get(i).size() % 2 == 0 )
            {
                HecDouble d = data.get(i).get(pos).hecValue();
                d.add(data.get(i).get(pos-1).value());
                d.divide(2.0);
                median_val.add(i,d);
            }
            else
            {
                median_val.add(i,data.get(i).get(pos).hecValue());
            }
            
            // get the mean value and mean difference
            
            double mean = 0.0;
            double diff = 0.0;
            for( int j = 0; j < data.get(i).size(); ++j )
            {
                mean += data.get(i).get(j).value();
                diff += data.get(i).get(j).diff();
            }
            
            mean /= data.get(i).size();
            mean_val.add(i,new HecDouble(mean));
            
            diff /= data.get(i).size();
            diff_val.add(i,new HecDouble(diff));
            
            // get the standard deviation
            
            double sum = 0;
            double val = 0;
            
            for( int j = 0; j < data.get(i).size(); ++j )
            {
                val = data.get(i).get(j).value();
                val -= mean_val.get(i).value();
                val *= val;
                sum += val; 
            }
            
            sum /= data.get(i).size();
            std_val.add(i,new HecDouble(java.lang.Math.sqrt(sum)) );
               
       }
          
    }
    
    /** Remove any user defined durations */
    
    void clearAdditionalDurations()
    {
        jSeparator2.setVisible(false);
        
        for( int i = 0; i < customDuration.size(); ++i )
        {
            jDurationMenu.remove(customDuration.get(i));
        }
    }
    
    /** Write the results into a StringBuffer then display and save the buffer */
    
    void wsWriteTable()
    {
        StringBuffer buffer = new StringBuffer();
        
        // show the file name
        buffer.append("DSS File:\t");
        buffer.append(lastFile.getAbsolutePath());
        buffer.append("\n");
        
        // show the DSS path
        buffer.append("DSS Path:\t");
        buffer.append(currentPath);
        buffer.append("\n");
        
        //give the growing season window
        buffer.append("Season Start:\t");
        buffer.append(windowStart);
        buffer.append("\n");
        buffer.append("Season Stop:\t");
        buffer.append(windowStop);
        buffer.append("\n");
        
        //give the year range
        buffer.append("Start Year:\t");
        buffer.append(startYear);
        buffer.append("\n");
        buffer.append("Stop Year:\t");
        buffer.append(stopYear);
        buffer.append("\n");        
      
        // show the date and time
        Date date = new Date();
        buffer.append("Date\t");
        buffer.append(DateFormat.getDateInstance().format(date) );
        buffer.append("\t");
        buffer.append(DateFormat.getTimeInstance().format(date) );
        buffer.append("\n\n");        
        
        // blank line
        buffer.append("\n");
        
        //make the table header
        buffer.append("Duration\t");
        if ( calcMedian ) buffer.append("Median Stage\t");
        if ( calcMean ) buffer.append("Mean Stage\t");
        if ( calcStd ) buffer.append("Std Dev\t");
        if ( calcDiff ) buffer.append("Mean Diff\t");
        buffer.append("\n");
        buffer.append("--------\t");
        if ( calcMedian ) buffer.append("------------\t");
        if ( calcMean ) buffer.append("----------\t");
        if ( calcStd ) buffer.append("-------\t");
        if ( calcDiff ) buffer.append("---------\t");    
        buffer.append("\n");
        
        for ( int i = 0; i < durations.size(); ++i )
        {
            double val  = durations.get(i).doubleValue();
            val *= 100;
            buffer.append( Double.toString(val) );
            buffer.append("%");
            buffer.append("\t");
            if ( calcMedian)
            {
                buffer.append(median_val.get(i).string(2,false));
                buffer.append("\t");
            }
            if ( calcMean )
            {
                buffer.append(mean_val.get(i).string(2,false));
                buffer.append("\t");
            }
            if ( calcStd )
            {
                buffer.append(std_val.get(i).string(2,false));
                buffer.append("\t");
            }
            if ( calcDiff )
            {
                buffer.append(diff_val.get(i).string(2,false));
            }
            buffer.append("\n");
        }
        
        if ( showYearData )
        {
            buffer.append("\n\n");
            
            for( int i = 0; i < durations.size(); ++i )
            {
                buffer.append("Duration:\t");
                buffer.append(Double.toString(durations.get(i).doubleValue() * 100));
                buffer.append("%\n");
                
                buffer.append("Days:\t");
                buffer.append(duration_length.get(i).toString());
                buffer.append("\n\n");
                
                buffer.append("Rank\tValue\tWindow Start\tWindow Stop\n");
                
                for( int j = 0; j < data.get(i).size(); ++j )
                {
                    int pos = data.get(i).size() - j - 1;
                    
                    buffer.append(Integer.toString(j+1));
                    buffer.append("\t");
                    buffer.append(data.get(i).get(pos).hecValue().string(2,false));
                    buffer.append("\t");
                    HecTime t = data.get(i).get(pos).date();
                    buffer.append(t.date(1));
                    buffer.append("\t");
                    t.setTimeIncrement(HecTime.DAY_INCREMENT);
                    t.add(duration_length.get(i).intValue()-1);
                    buffer.append(t.date(1));
                    buffer.append("\n");                    
                }
                
                buffer.append("\n");
            }
        }
        
        String[] parts = currentPath.split("/");
        StringBuffer name = new StringBuffer();
        name.append(parts[1]);
        name.append("_");
        name.append(parts[2]);
        name.append("_");
        name.append(parts[6]);
        name.append(".txt");
        
        String fileName = name.toString();
        
        String s = buffer.toString();
        
        String filePath = ( outputDirPath == "") ? fileName : outputDirPath + "/" + fileName;
        try
        {
            java.io.FileWriter writer = new java.io.FileWriter(filePath);
            writer.write(s);
            writer.close();
        }
        catch(java.io.IOException io_excep)
        {
           javax.swing.JOptionPane.showMessageDialog(this, 
                   "Error writing file " + filePath,
                   "IOError", 
                   javax.swing.JOptionPane.ERROR_MESSAGE);
      
        }        
        
        ReportDisplay display = new ReportDisplay();
        display.setTitle(fileName);
        display.setFilePath(filePath);
        display.setText(s);
        display.setVisible(true);
        
    }

    /** Read the control values for statistical computation form the GUI */
    
    private void vsReadGUI()
    {
        // read the options for stage statistics
        vscMean = jMeanStageCheckBox.isSelected();
        vscMedian = jMedianStageCheckBox.isSelected();
        vscVariance = jStageVarCheckBox.isSelected();
        vscSkew = jStageSkewCheckBox.isSelected();
        vscRange = jRangeCheckBox.isSelected();
        vscSpread = jSpreadCheckBox.isSelected();
        vscMin = jMinCheckBox.isSelected();
        vscMax = jMaxCheckBox.isSelected();
        
        // read the options for pulses
        
        vscHighPulseCount = jNumHPCheckBox.isSelected();
        vscHighPulseDur = jMeanHPDurCheckBox.isSelected();
        vscLowPulseCount = jNumLPCheckBox.isSelected();
        vscLowPulseDur = jMeanLPDurCheckBox.isSelected();
        
        // rise and fall recording
        
        vscNumRises = jNumRisesCheckBox.isSelected();
        vscMeanRise = jMeanRiseCheckBox.isSelected();
        vscNumFalls = jNumFallsCheckBox.isSelected();
        vscMeanFall = jMeanFallCheckBox.isSelected();
        

        startYear = jStartYearField.getText();
        stopYear = jStopYearField.getText();        
    }
    
    /** Calculate statistics using the data in the selected path */
    
    private void vsRunPath()
    { 
        int start = Integer.parseInt(startYear);
        int stop = Integer.parseInt(stopYear);
        
        // initialize the main data structures
        
        // determine the number of years that will be run
        numYears = stop - start + 1;
        
        vsData = new ArrayList<VarStatDataExt>(numYears);
        vsStages = new ArrayList<Double>();

        for( int i = 0; i < durations.size(); ++i )
        {
            data.add(new ArrayList<YearData>(numYears));              
        }        
        HecTimeSeries ts =new HecTimeSeries();
        
        for( int i = 0; i < numYears; ++i )
        {
            String s1 = "01JAN" + Integer.toString(start + i);
            String s2 = "31DEC" + Integer.toString(start + i);
            
            startTime = new HecTime(s1);
            stopTime = new HecTime(s2);
            
       
            
            ts.setPathname(currentPath);
            ts.setTimeWindow(startTime,stopTime);
            
            days = new HecTimeArray();
            values = new HecDoubleArray();            
            
            int rv = ts.read(days,values);
            
            if ( rv > 0 )
            {
                vsCalcYearStats();
                
                vsCollectStages();
            }
        }
        
        vsCalcSummaryStats();
        
        vsCalcRangeAndSpread();
        
        vsWriteTable();
        closeDSSFile(ts);
                
    }    
    
    /** Process one year or data and calculate stats for it */
    
    private void vsCalcYearStats()
    {
        VarStatData yearData = new VarStatData();
        
        double[] valuesArray = values.getDoubleArray();
        
        vsData.add(new VarStatDataExt(valuesArray,startTime,stopTime));   
    }
    
    /** Record the current year of stats so that period of record stats can be collected */
    
    private void vsCollectStages()
    {
        vsStages.ensureCapacity(vsStages.size() + values.numberElements());
        
        for(int i = 0; i < values.numberElements(); ++i)
        {
            vsStages.add(values.element(i).value());
        }
    }
    
    /** Calculate stats on the yearly statistics */
    
    private void vsCalcSummaryStats()
    {
        vsSummary = new VarStatSummaryData(vsData);
    }
    
    /** Calculate the stats for the period of record */
    
    private void vsCalcRangeAndSpread()
    {
        String s1 = "01JAN" + startYear;
        String s2 = "31DEC" + stopYear;
        
        double[] vals = new double[vsStages.size()];
        
        for(int i = 0; i < vsStages.size(); ++i)
        {
            vals[i] = vsStages.get(i).doubleValue();
        }
        
        vsStagesStats = new VarStatData(vals,new HecTime(s1),new HecTime(s2));
        
    }
    
    /** Create, display, and save the results tables */
    
    private void vsWriteTable()
    {   
        StringBuffer buffer = new StringBuffer();
        
        // show the file name
        buffer.append("DSS File:\t");
        buffer.append(lastFile.getAbsolutePath());
        buffer.append("\n");
        
        // show the DSS path
        buffer.append("DSS Path:\t");
        buffer.append(currentPath);
        buffer.append("\n");
        
        // show the date and time
        Date date = new Date();
        buffer.append("Date\t");
        buffer.append(DateFormat.getDateInstance().format(date) );
        buffer.append("\t");
        buffer.append(DateFormat.getTimeInstance().format(date) );
        buffer.append("\n\n");
        
        // write the sumary stats table to the buffer
        writeSummaryStageStatsTable(buffer);
        
        buffer.append("\n\n");
        
        // write the yearly stage stats table into the buffer
        writeYearlyStageStatsTable(buffer);
        
        buffer.append("\n\n");
        
        // write the sumary pulse stats table into the buffer
        writeSummaryPulseRFStatsTable(buffer);
        
        buffer.append("\n\n");
        
        // write the yearly pulse stats table into the buffer
        writeYearlyPulseRFStatsTable(buffer);
        
        buffer.append("\n\n");
        
        //write period of record stats
        writePeriodStatsTable(buffer);
        
        buffer.append("\n");
              
        // get the file name and path
        String fileName = getSaveName();
        String filePath = ( outputDirPath == "") ? fileName : outputDirPath + "/" + fileName;
        
        // get the buffer contents
        String s = buffer.toString();
        
        // save the file
        saveString(s,filePath);
        
        // display the text file
        ReportDisplay display = new ReportDisplay();
        display.setTitle(fileName);
        display.setFilePath(filePath);
        display.setText(s);
        display.setVisible(true);        
    }
    
    /** Write a table giving summary statistics about the stages or flows in the selected
     *  DSS path to the input StringBuffer. The table can be displayed by dislaying the contents
     *  of the string buffer */ 
    
    private void writeSummaryStageStatsTable(StringBuffer buffer)
    {
        buffer.append("Basic Stats Summary\n");
        buffer.append("Stat\tMin\tMax\tMean\tMedian\tVariance\n");
        
        if ( vscMin )
        {
            buffer.append("Min\t");
            buffer.append(HecDouble.string(vsSummary.minMin(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxMin(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanMin(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianMin(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceMin(),2,false));
            buffer.append("\n");
        }
        
        if ( vscMax )
        {
            buffer.append("Max\t");
            buffer.append(HecDouble.string(vsSummary.minMax(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxMax(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanMax(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianMax(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceMax(),2,false));
            buffer.append("\n");
        }
        
        if ( vscMean )
        {
            buffer.append("Mean\t");
            buffer.append(HecDouble.string(vsSummary.minMean(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxMean(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanMean(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianMean(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceMean(),2,false));
            buffer.append("\n");
        }
        
        if ( vscMedian )
        {
            buffer.append("Median\t");
            buffer.append(HecDouble.string(vsSummary.minMedian(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxMedian(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanMedian(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianMedian(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceMedian(),2,false));
            buffer.append("\n");
        }
        
        if ( vscVariance )
        {
            buffer.append("Variance\t");
            buffer.append(HecDouble.string(vsSummary.minVariance(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxVariance(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanVariance(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianVariance(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceVariance(),2,false));
            buffer.append("\n");
        }       
        
        if ( vscSkew )
        {
            buffer.append("Skew\t");
            buffer.append(HecDouble.string(vsSummary.minSkew(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxSkew(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanSkew(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianSkew(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceSkew(),4,false));
            buffer.append("\n");
        }        
         
        /*if ( vscRange )
        {
            // 10% - 90% range
            buffer.append("r10/90\t");
            buffer.append(HecDouble.string(vsSummary.minR10_90(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxR10_90(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanR10_90(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianR10_90(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceR10_90(),4,false));
            buffer.append("\n");
            
            // 20% - 80% range
            buffer.append("r20/80\t");
            buffer.append(HecDouble.string(vsSummary.minR20_80(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxR20_80(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanR20_80(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianR20_80(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceR20_80(),4,false));
            buffer.append("\n");  
            
            // 25% - 75% range
            buffer.append("r25/75\t");
            buffer.append(HecDouble.string(vsSummary.minR25_75(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxR25_75(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanR25_75(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianR25_75(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceR25_75(),4,false));
            buffer.append("\n");              
        }       
          
        if ( vscSpread )
        {
            // 10% - 90% spread
            buffer.append("s10/90\t");
            buffer.append(HecDouble.string(vsSummary.minS10_90(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxS10_90(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanS10_90(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianS10_90(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceS10_90(),4,false));
            buffer.append("\n");
            
            // 20% - 80% spread
            buffer.append("s20/80\t");
            buffer.append(HecDouble.string(vsSummary.minS20_80(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxS20_80(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanS20_80(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianS20_80(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceS20_80(),4,false));
            buffer.append("\n");  
            
            // 25% - 75% spread
            buffer.append("s25/75\t");
            buffer.append(HecDouble.string(vsSummary.minS25_75(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxS25_75(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanS25_75(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianS25_75(),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceS25_75(),4,false));
            buffer.append("\n");              
        } */      
        
    }
    
    /** Write a table giving yearly statistics about the stages or flows in the selected
     *  DSS path to the input StringBuffer. The table can be displayed by dislaying the contents
     *  of the string buffer */ 
    
    private void writeYearlyStageStatsTable(StringBuffer buffer)
    {
        buffer.append("Basic Stats\n");
        buffer.append("Year\t");
        if ( vscMin ) { buffer.append("Min\t"); }
        if ( vscMax ) { buffer.append("Max\t"); }
        if ( vscMean ) { buffer.append("Mean\t"); }
        if ( vscMedian ) { buffer.append("Median\t"); }
        if ( vscVariance ) { buffer.append("Variance\t"); }
        if ( vscSkew ) { buffer.append("Skew\t"); }
        //if ( vscRange ) { buffer.append("r10/90\tr20/80\tr25/75\t"); }
        //if ( vscSpread ) { buffer.append("s10/90\ts20/80\ts25/75\t"); }
        buffer.append("\n");
        
        for(int i = 0; i <  vsData.size(); ++i )
        {
            buffer.append(vsData.get(i).startYear());
            buffer.append("\t");
            
            if ( vscMin )
            {
                buffer.append( HecDouble.string(vsData.get(i).min(),2,false) );
                buffer.append("\t");                
            }
            
            if ( vscMax )
            {
                buffer.append( HecDouble.string(vsData.get(i).max(),2,false) );
                buffer.append("\t");                
            }
            
            if ( vscMean )
            {
                buffer.append( HecDouble.string(vsData.get(i).mean(),2,false) );
                buffer.append("\t");
            }
            
            if ( vscMedian )
            {
                buffer.append( HecDouble.string(vsData.get(i).median(),2,false) );
                buffer.append("\t");
            }
            
            if ( vscVariance )
            {
                buffer.append( HecDouble.string(vsData.get(i).variance(),2,false) );
                buffer.append("\t");
            }
            
            if ( vscSkew )
            {
                buffer.append( HecDouble.string(vsData.get(i).skew(),2,false) );
                buffer.append("\t");
            }
            
            /*if ( vscRange )
            {
                buffer.append( HecDouble.string(vsData.get(i).rangeRatio(.10,.90),2,false));
                buffer.append("\t");
                buffer.append( HecDouble.string(vsData.get(i).rangeRatio(.20,.80),2,false));
                buffer.append("\t");
                buffer.append( HecDouble.string(vsData.get(i).rangeRatio(.25,.75),2,false));
                buffer.append("\t");                
            }
            
            if ( vscSpread )
            {
                buffer.append( HecDouble.string(vsData.get(i).spreadRatio(.10,.90),4,false));
                buffer.append("\t");
                buffer.append( HecDouble.string(vsData.get(i).spreadRatio(.20,.80),4,false));
                buffer.append("\t");
                buffer.append( HecDouble.string(vsData.get(i).spreadRatio(.25,.75),4,false));
                buffer.append("\t");                
            } */           
            
            buffer.append("\n");
        }       
    }
 
    /** Write a table giving summary statistics about the pulses, rissing days, and falling daays in the selected
     *  DSS path to the input StringBuffer. The table can be displayed by dislaying the contents
     *  of the string buffer */     
    
    private void writeSummaryPulseRFStatsTable(StringBuffer buffer)
    {
        buffer.append("Pulse, Rise & Fall Stats Summary\n");
        buffer.append("Stat\t\tMin\tMax\tMean\tMedian\tVariance\n");
        
        if ( vscHighPulseCount )
        {
            buffer.append("Num High Pulses\t");
            buffer.append(HecDouble.string(vsSummary.minNumHighPulses(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxNumHighPulses(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanNumHighPulses(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianNumHighPulses(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceNumHighPulses(),2,false));
            buffer.append("\n");            
        }
        
        if ( vscHighPulseDur )
        {
            buffer.append("High Pulse Duration\t");
            buffer.append(HecDouble.string(vsSummary.minHighPulseDur(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxHighPulseDur(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanHighPulseDur(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianHighPulseDur(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceHighPulseDuration(),2,false));
            buffer.append("\n");            
        }
        
        if ( vscLowPulseCount )
        {
            buffer.append("Num Low Pulses\t");
            buffer.append(HecDouble.string(vsSummary.minNumLowPulses(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxNumLowPulses(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanNumLowPulses(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianNumLowPulses(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceNumLowPulses(),2,false));
            buffer.append("\n");            
        }
           
        if ( vscLowPulseDur )
        {
            buffer.append("Low Pulse Duration\t");
            buffer.append(HecDouble.string(vsSummary.minLowPulseDur(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxLowPulseDur(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanLowPulseDur(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianLowPulseDur(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceLowPulseDuration(),2,false));
            buffer.append("\n");            
        }
        
        if ( vscNumRises )
        {
            buffer.append("Num Rises\t\t");
            buffer.append(HecDouble.string(vsSummary.minNumRises(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxNumRises(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanNumRises(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianNumRises(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceNumRises(),2,false));
            buffer.append("\n");               
        }
        
        if ( vscMeanRise )
        {
            buffer.append("Mean Rise\t\t");
            buffer.append(HecDouble.string(vsSummary.minMeanRise(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxMeanRise(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanMeanRise(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianMeanRise(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceMeanRise(),2,false));
            buffer.append("\n");               
        }
        
        if ( vscNumFalls )
        {
            buffer.append("Num Falls\t\t");
            buffer.append(HecDouble.string(vsSummary.minNumFalls(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxNumFalls(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanNumFalls(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianNumFalls(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceNumFalls(),2,false));
            buffer.append("\n");               
        }
        
        if ( vscMeanRise )
        {
            buffer.append("Mean Fall\t\t");
            buffer.append(HecDouble.string(vsSummary.minMeanFall(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.maxMeanFall(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.meanMeanFall(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.medianMeanFall(),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsSummary.varianceMeanFall(),2,false));
            buffer.append("\n");               
        }          
    }
 
    /** Write a table giving summary statistics about the pulses, rissing days, and falling daays in the selected
     *  DSS path to the input StringBuffer. The table can be displayed by dislaying the contents
     *  of the string buffer */    
    
    private void writeYearlyPulseRFStatsTable(StringBuffer buffer)
    {
        buffer.append("Pulse, Rise & Fall Stats\n");
        buffer.append("Year\t");
        if ( vscHighPulseCount ) { buffer.append("HP Count\t"); }
        if ( vscHighPulseDur ) { buffer.append("HP Dur\t"); }
        if ( vscLowPulseCount ) { buffer.append("LP Count\t"); }
        if ( vscLowPulseDur ) { buffer.append("LP Dur\t"); }
        if ( vscNumRises ) { buffer.append("Num Rises\t"); }
        if ( vscMeanRise ) { buffer.append("Mean Rise\t"); }
        if ( vscNumFalls ) { buffer.append("Num Falls\t"); }
        if ( vscMeanFall ) { buffer.append("Mean Fall\t"); }        
        buffer.append("\n");
        
        for(int i = 0; i <  vsData.size(); ++i )
        {
            buffer.append(vsData.get(i).startYear());
            buffer.append("\t");
            
            if ( vscHighPulseCount )
            {
                buffer.append(HecDouble.string(vsData.get(i).highPulses(),2,false));
                buffer.append("\t");
            }
            
            if ( vscHighPulseDur )
            {
                buffer.append(HecDouble.string(vsData.get(i).averageHighPulseDuration(),2,false));
                buffer.append("\t");
            }
            
            if ( vscLowPulseCount )
            {
                buffer.append(HecDouble.string(vsData.get(i).lowPulses(),2,false));
                buffer.append("\t");
            }
            
            if ( vscLowPulseDur )
            {
                buffer.append(HecDouble.string(vsData.get(i).averageLowPulseDuration(),2,false));
                buffer.append("\t");
            }
            
            if ( vscNumRises )
            {
                buffer.append(HecDouble.string(vsData.get(i).numRises(),2,false));
                buffer.append("\t");
            }
            
            if ( vscMeanRise )
            {
                buffer.append(HecDouble.string(vsData.get(i).averageRiseAmount(),2,false));
                buffer.append("\t");
            }
            
            if ( vscNumFalls )
            {
                buffer.append(HecDouble.string(vsData.get(i).numFalls(),2,false));
                buffer.append("\t");
            }
            
            if ( vscMeanFall )
            {
                buffer.append(HecDouble.string(vsData.get(i).averageFallAmount(),2,false));
                buffer.append("\t");
            }            
            
            buffer.append("\n");
        }
    }
    
    /** Write a table giving summary statistics about the range and spread of the data in the
     *  selected DSS path */
    
    private void writePeriodStatsTable(StringBuffer buffer)
    {
        buffer.append("Period Stats\n\n");
        
        buffer.append("Min\t");
        buffer.append(HecDouble.string(vsStagesStats.min(),2,false));
        buffer.append("\n");

        buffer.append("Max\t");
        buffer.append(HecDouble.string(vsStagesStats.max(),2,false));
        buffer.append("\n");
        
        buffer.append("Mean\t");
        buffer.append(HecDouble.string(vsStagesStats.mean(),2,false));
        buffer.append("\n");
        
        buffer.append("Median\t");
        buffer.append(HecDouble.string(vsStagesStats.median(),2,false));
        buffer.append("\n");
        
        buffer.append("Skew\t");
        buffer.append(HecDouble.string(vsStagesStats.skew(),2,false));
        buffer.append("\n");
           
        buffer.append("Percentile\t10%\t20%\t25%\t50%\t75%\t80%\t90%\n");
        buffer.append("\t");
        buffer.append(HecDouble.string(vsStagesStats.percentile(.10),2,false));
        buffer.append("\t");
        buffer.append(HecDouble.string(vsStagesStats.percentile(.20),2,false));
        buffer.append("\t");
        buffer.append(HecDouble.string(vsStagesStats.q1(),2,false));        
        buffer.append("\t");
        buffer.append(HecDouble.string(vsStagesStats.median(),2,false));
        buffer.append("\t");
        buffer.append(HecDouble.string(vsStagesStats.q3(),2,false));
        buffer.append("\t");
        buffer.append(HecDouble.string(vsStagesStats.percentile(.80),2,false));
        buffer.append("\t");
        buffer.append(HecDouble.string(vsStagesStats.percentile(.90),2,false));
        buffer.append("\n");
        
        if ( vscRange || vscSpread)
        {
            buffer.append("\n");
            buffer.append("\t10/90\t20/80\t25/75\n");
        }
        
        if ( vscRange )
        {
            buffer.append("Range\t");
            buffer.append(HecDouble.string(vsStagesStats.rangeRatio(.10,.90),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsStagesStats.rangeRatio(.20,.80),2,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsStagesStats.rangeRatio(.25,.75),2,false));
            buffer.append("\n");
        }
        
        if ( vscSpread )
        {
            buffer.append("Spread\t");
            buffer.append(HecDouble.string(vsStagesStats.spreadRatio(.10,.90),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsStagesStats.spreadRatio(.20,.80),4,false));
            buffer.append("\t");
            buffer.append(HecDouble.string(vsStagesStats.spreadRatio(.25,.75),4,false));
            buffer.append("\n");
        }
        
        
        
    }
    
    /** Generate the default save name assoiciated with the sellected DSS Path */
    
    private String getSaveName()
    {
        String[] parts = currentPath.split("/");
        StringBuffer name = new StringBuffer();
        name.append(parts[1]);
        name.append("_");
        name.append(parts[2]);
        name.append("_");
        name.append(parts[6]);
        name.append(".stats.txt");
        
        return name.toString();        
    }
    
    /** Write the contents of data to a file named path. */
    
    private void saveString(String data, String path)
    {
        try
        {
            java.io.FileWriter writer = new java.io.FileWriter(path);
            writer.write(data);
            writer.close();
        }
        catch(java.io.IOException io_excep)
        {
           javax.swing.JOptionPane.showMessageDialog(this, 
                   "Error writing file " + path,
                   "IOError", 
                   javax.swing.JOptionPane.ERROR_MESSAGE);
      
        }          
    }
    
    /** This class holds the required data for one year of data in the wetsort algorithm. */
    
    private class YearData
    {
        /** Make a new YearData object */
        
        public YearData()
        {
           pVal = new HecDouble(0.0);
           pDiff = new HecDouble(0.0);
           pDate = new HecTime();
        }
        
        /** Make a YearData object with
         *  v: the wetsort value for the new object
         *  d: the difference value for the new object
         *  t: the time value associated with v */ 
        
        public YearData(HecDouble v, HecDouble d, HecTime t)
        {
            pVal = new HecDouble(v);
            pDiff = new HecDouble(d);
            pDate = new HecTime(t);
        }
        
        /** Return the wetsort value as a HecDoubl. 
         *  The resulting value is a new variable that can be freely modified */
        
        public HecDouble hecValue()
        {
            return new HecDouble(pVal);
        }
        
        /** Return the wetsort value as a double */
        
        public double value()
        {
            return pVal.value();
        }
        
        /** Set the wetsort value
         *  double v: The value to set the wetsort value to */
        
        public void value(double v)
        {
            pVal.set(v);
        }
        
        /** Set the wetsort value
         *  HecDouble v: The value to set the wetsort value to */
        
        public void value(HecDouble v)
        {
            pVal.set(v);
        }
        
        /** Set the wetsort value
         *  String s: The string rep of the value to set the wetsort value to */  
        public void value(String s)
        {
            pVal.set(s);
        }
        
        /** get the differnce bwtween the wetsort value and its period max  */
        
        public double diff()
        {
            return pDiff.value();
        }
        
        /** Set the differnce bwtween the wetsort value and its period max
         *  double v: The value to set the difference to */
        
        public void diff(double v)
        {
            pDiff.set(v);
        }
        
        /** Set the differnce bwtween the wetsort value and its period max
         *  HecDouble v: The value to set the difference to */
        
        public void diff(HecDouble v)
        {
            pDiff.set(v);
        }       
        
        /** Set the differnce bwtween the wetsort value and its period max
         *  Strintg s: The string rep of the value to set the difference to */
        
        public void diff(String s)
        {
            pDiff.set(s);
        }
        
        /** The first day of the window that the wetsort value comes from */
        
        public HecTime date()
        {
            return new HecTime(pDate);
        }
        
        /** Set the first day of the window that the wetsort value come from 
         *  HecTime t: The new time */
        
        public void date(HecTime t)
        {
            new HecTime(pDate);
        }
     
        /** Set the first day of the window that the wetsort value come from 
         *  String s: The new time as a string */      
        
        public void date(String s)
        {
            pDate.set(s);
        }
     
        /** Set the first day of the window that the wetsort value come from 
         *  String d: the new data as a string 
         *  String t: the new time as a string */
        
        public void date(String d, String t)
        {
            pDate.set(d,t);
        }
        
        /** The start time of the wetsort window as a string */
        
        public String dateString()
        {
            return pDate.toString();
        }
        
        /** The start time of the wetsort value as in string in the requested style */
        
        public String dateString(int style)
        {
            return pDate.toString(style);
        }
        
        /** The wetsort value */
        private HecDouble pVal;
        
        /** The differnece bwtween the wetsort value and its window max */
        private HecDouble pDiff;
        
        /** The first day of the window that the wetsort value came form */
        private HecTime pDate;
    }

        
    /** This class takes a period of stages as input and provides
    *   statistics about min, max, mean, median, quartiltes, range, and spread of the input period. */      
    
    private class VarStatData
    {
        
        /** Create a new VarStatData object */
        
        public VarStatData()
        {
            init();
        }
        
        /** Creat a new VarStat Object that gives statistics about its input values.
         *  The values are assumed to cover the range form startTime to stopTime in 
         *  even intervals */
        
        public VarStatData(double[] values, HecTime startTime, HecTime stopTime)
        {
            init();
            
            stages = values;
            
            setTimeWindow(startTime,stopTime);
            calcStageStats();
        }
        
        /** Set the time window for the class data */
        
        public void setTimeWindow(HecTime startTime, HecTime stopTime)
        {
            pStartTime = new HecTime(startTime);
            pStopTime = new HecTime(stopTime);
        }
        
        /** Return throws mean value of the objects data */
        
        public double mean()
        {
            return pMean;
        }
        
        /** Return the median value of the objects data */
        
        public double median()
        {
            return q[2];
        }
        
        /** Return the variance of the objects data */
     
        public double variance()
        {
            return pVar;
        }
        
        /** Return the standard deviation of the objects data */
        
        public double std()
        {
            return java.lang.Math.sqrt(pVar);
        }
        
        /** Return the skew of the objects data */
        
        public double skew()
        {
            return pMean / q[2];
        }
        
        /** Return the request range ratio.
         *  The range ratio is one percentile divided by another.
         *  rangeRatio(.25,.75) return the 25th percentile / 75th percentile */
        
        public double rangeRatio(double start, double stop)
        {
            int n1, n2;
            double num = sortedStages.length + 1;
            
            n1 = (int) java.lang.Math.round(num * start);
            // round x.5 down
            n2 = (int) java.lang.Math.ceil( (num * stop) - 0.5 );
            
            return sortedStages[n1] / sortedStages[n2];            
        }
        
        /** Return the requested spreadRatio.
         *  A spreadRatio is a rangeRatio divided by the median */
        
        public double spreadRatio(double start, double stop)
        {
            return rangeRatio(start,stop) / q[2];        
        }
        
        /** Return the min of the data set */
        
        public double min()
        {
            return q[0];
        }
        
        /** Return the max of the data set */
        
        public double max()
        {
            return q[4];
        }
        
        /** Return the 1st quartile of the data set */
        
        public double q1()
        {
            return q[1];
        }
        
        /** return the 3rd quartile of the data set */
        
        public double q3()
        {
            return q[3];
        }
        
        /** return the request percentile of the data set 
         *  Throws an Illegal ArguementException if the input parameter
         *  is not in the range [0,1] */
        
        public double percentile(double d) throws IllegalArgumentException
        {
            int n;
            double num = sortedStages.length + 1;
            
            if ( 0 <= d && d < 0.5)
            {
                n = (int) java.lang.Math.round(num * d);
                return sortedStages[n];
            }
            else if ( 0.5 < d && d <= 1.0)
            {
                n = (int) java.lang.Math.ceil( (num * d) - 0.5 );
                return sortedStages[n];
            }
            else if ( d == 0.5 )
            {
                return q[2];
            }
            else
            {
               throw new java.lang.IllegalArgumentException("Illegal input value. The input value must be in the range [0,1]");
            }
        }
        
        /** Return the day associated with the first data value */
        
        public int startDay()
        {
            return pStartTime.day();
        }
        
        /** Return the day associated with the last data value */
        
        public int stopDay()
        {
            return pStartTime.day();
        }
        
        /** Return the month associated with the first data value */
        
        public int startMonth()
        {
            return pStartTime.month();
        }
        
        /** Return the month associated with the first data value */
        
        public int stopMonth()
        {
            return pStopTime.month();
        }
        
        /** Return the year associated with the first data value */
        
        public int startYear()
        {
            return pStartTime.year();
        }
        
        /** Return the year associated with the first data value */
        
        public int stopYear()
        {
            return pStopTime.year();
        }
        
        /** Initalize the member variables */
        
        private void init()
        {
            pMean = 0;
            pVar = 0;
            
            q = new double[5];
            q[0] = 0; q[1] = 0; q[2] = 0; q[3] = 0; q[4] = 0;
            
            pStartTime = new HecTime();
            pStopTime = new HecTime();

        }
        
        /** Calculate the statistics for the objects data set */
              
        void calcStageStats()
        {
            // get a sorted copy
            sortedStages = (double[]) stages.clone();
            java.util.Arrays.sort(sortedStages);
            
            // calculate the mean
            calcMean();
            
            // calculate the variance
            calcVariance();
            
            //calculated the quartiles
            calcQuartiles();
                      
        }
       
        /** Calculate the data set mean value */
        
        private void calcMean()
        {
            // calculate the mean
            
            pMean = 0;
            for( int i = 0; i < stages.length; ++i )
            {
                pMean += stages[i];
            }
            pMean /= stages.length;            
        }
        
        /** Calculate the variance for the data set */
        
        private void calcVariance()
        {
            // calculate the mean
            
            double val;
            pVar = 0;
            for( int i = 0; i < stages.length; ++i )
            {
                val = stages[i] - pMean;
                val *= val;
                pVar += val;
            }
            pVar /= stages.length -1; 
        }
        
        /** Calculate the quartile values for the data set.
         *  This also calculates the mean */
        
        private void calcQuartiles()
        {
            int n;
            double num = sortedStages.length + 1;
            
            // calculate the q points
            q[0] = sortedStages[0];
            
            n = (int) java.lang.Math.round(num/4.0);
            q[1] = sortedStages[ n - 1 ];
         
            // The q[2] is the median 
            
            if ( sortedStages.length % 2 == 1)
            {
                q[2] = sortedStages[ sortedStages.length / 2 ];
            }
            else
            {
                n = sortedStages.length / 2;
                q[2] = sortedStages[n-1];
                q[2] += sortedStages[n];
                q[2] /= 2;
            }
            
            // this calculation is n rounded to the nearest int except x.5 rounds down
            n = (int) java.lang.Math.ceil( ( (3 * num) / 4.0 ) - 0.5 );            
            q[3] = sortedStages[ n - 1 ];
            
            q[4] = sortedStages[ sortedStages.length - 1];           
        }       
    
        // stages
        /** Array that stores the object dataset */
        protected double[] stages;
        
        /** Array that sotes a sorted copy of the object dataset */
        protected double[] sortedStages;
        
        // stage stats
        /** The mean value */
        protected double pMean;
        
        /** The variance */
        protected double pVar;
        
        /** The quartiles */
        protected double[] q;
        
        // TimeWindow
        /** The being time of the data */
        protected HecTime pStartTime;
        
        /** The end time of the data */
        protected HecTime pStopTime;
        
    }    
         

    /** This class extends VarStatData and provides additional statistics on the number of high and low 
     *  pulses and the number of rising and falling days */
    
    
    private class VarStatDataExt extends VarStatData
    {
      
        /** create a new VarStatDataExt object */
        
        public VarStatDataExt()
        {
            init();
        }
        
        /** create a new VarStatDataExt object that provides summary statistics for 'values'.
         *  The the contents of values are assumed to be evenly spaced temporarly between
         *  'startTime' and 'stopTime' */
        
        public VarStatDataExt(double[] values, HecTime startTime, HecTime stopTime)
        {
            super(values,startTime,stopTime);
            
            init();
            
            calcStats();
        }
        
        /** calculate statistics for the class data */
        
        public void calcStats()
        {
            countRiseAndFall();
            countPulses();
        }
        
        /**  Return the number of high pulses in the data set.
             A high pulse is a continous period where the stage or flow value
             recorded is greater than or equal to 75 percentile of the data set*/
        
        public int highPulses()
        {        
            return pHighPulses;
        }
        
        /** Return the number of low pulses in the data set 
         *  A low pulse is a continous period where the stage or flow value
         *  recorded is greater than or equal to 25th percentile of the data set*/
        
        public int lowPulses()
        {
            return pLowPulses;
        }
        
        /**  Return the average duration of high pulses in the dataset.
             A high pulse is a continous period where the stage or flow value
             recorded is greater than or equal to 75th percentile of the data set*/
        
        public double averageHighPulseDuration()
        {
            return pHighPulseDur;
        }
        
        /**  Return the average duration of low pulses in the dataset 
             A low pulse is a continous period where the stage or flow value
             recorded is greater than or equal to 25th percentile of the data set*/
        
        public double averageLowPulseDuration()
        {
            return pLowPulseDur;
        }
        
        /** Return the number of days durring which the current days value is higher then the 
         *  previous days value */
        
        public int numRises()
        {
            return pNumRises;
        }
        
        /** Return the number of days durring which the current days value is low then the 
         *  previous days value */
            
        public int numFalls()
        {
            return pNumFalls;
        }

        /** Return the average change in value durring a rissing day */
        
        public double averageRiseAmount()
        {
            return pMeanRise;
        }
        
        /** Return the average change in value durring a falling day */
        
        public double averageFallAmount()
        {
            return pMeanFall;
        }
        
        /** Set class members to thier default values */
        
        private void init()
        {     
            pHighPulses = 0;
            pHighPulseDur = 0;
            
            pLowPulses = 0;
            pLowPulseDur = 0;
            
            pNumRises = 0;
            pMeanRise = 0;
            
            pNumFalls = 0;
            pMeanFall = 0;

        }
        
        /** Count the number of rissing and falling days and calculate the amount 
         *  of the average rise and fall */
        
        private void countRiseAndFall()
        {
            pNumRises = 0;
            pNumFalls = 0;
            pMeanRise = 0;
            pMeanFall = 0;
            
            for( int i = 0; i < stages.length -1 ; )
            {                      
                for( int j = i + 1; j < stages.length && stages[j-1] < stages[j]; ++j)
                {
                    ++i;
                    ++pNumRises;
                    pMeanRise += stages[j] - stages[j-1]; 
                }
                
                for( int j = i + 1; j < stages.length && stages[j-1] > stages[j]; ++j)
                {
                    ++i;
                    ++pNumFalls;
                    pMeanFall += stages[j] - stages[j-1];
                }
                
                if ( i < stages.length - 1 && stages[i] == stages[i+1] )
                {
                    ++i;
                }
                              
            }
            
            pMeanRise /= pNumRises;
            pMeanFall /= pNumFalls;
            
        }
        
        /** Count the number and duration of high and low pulses */
        
        private void countPulses()
        {
            pHighPulses = 0;
            pHighPulseDur = 0;
            pLowPulses = 0;
            pLowPulseDur = 0;
            
            int pos = 0;
            int i = 0;
            
            double val;
            
            // count the pulses and ancumulate data
            
            while(pos < stages.length)
            {
                // is a high pulse starting
                if ( stages[pos] >= q[3] )
                {
                    i = 1;
                    val = stages[pos];
                    
                    while( pos + i < stages.length && stages[pos+i] > q[3] )
                    {
                        val += stages[pos+i++];
                    }
                    
                    val /= i;
                    
                    pHighPulses += 1;
                    pHighPulseDur += i;
                    
                    pos += i;
                    continue;
                }
                
                // is a low pulse starting
                if ( stages[pos] <= q[1] )
                {
                    i = 1;
                    val = stages[pos];
                    
                    while( pos + i < stages.length && stages[pos+i] <= q[1] )
                    {
                        val += stages[pos+i++];
                    }
                    
                    val /= i;
                    
                    pLowPulses += 1;
                    pLowPulseDur += i;
                    
                    pos += i;
                    continue;
                }
                
                pos += 1;
            }
            
            // get the average duration of the pulses
            pHighPulseDur /= pHighPulses;
            pLowPulseDur /= pLowPulses;
            
            
        }
        
        // high pulses
        /** The number of High Pulses */
        private int pHighPulses;
        
        /** The average High Pulse duration */
        private double pHighPulseDur;
       
        // low pulses
        /** The number of Low Pulses */
        private int pLowPulses;
        
        /** The average low pulse duration */
        private double pLowPulseDur;
        
        // rises
        /** The number of days of rissing stages */
        private int pNumRises;
        /** The mean change in value on rissing days */
        private double pMeanRise;
        
        // falls
        /** The number of days of falling stages */
        private int pNumFalls;
        
        /** The mean change in value on falling days */
        private double pMeanFall;
       
    }

    /** This class provides summary statistics from an array of VarStatDataExt objects */       
    
    private class VarStatSummaryData 
    {              
        /** Make a new VarStatSummaryData object */
        
        public VarStatSummaryData()
        {
            init();
        }
        
        /** Make a new VarStatSummaryData object that summarises the contents of inputData */
        
        public VarStatSummaryData(ArrayList<VarStatDataExt> inputData)
        {
            init();
            
            pData = inputData;
            
            calcStats();
        }
        
        /** Return the minimum of the input minimums */
        
        public double minMin()
        {
            return pMinMin.value();
        }
        
        /** Return the maximum of the input minimums */
        
        public double maxMin()
        {
            return pMaxMin.value();
        }
        
        /** Return the mean of the input minimums */
        
        public double meanMin()
        {
            return pMeanMin.value();
        }
        
        /** Return the median of the input minimums */
        
        public double medianMin()
        {
            return pMedianMin.value();
        }
        
        /** Return the variance of the input minimums */
        
        public double varianceMin()
        {
            return pVarianceMin.value();
        }
        
        /** Return the minimum of the input maximums */
        
        public double minMax()
        {
            return pMinMax.value();
        }
        
        /** Return the maximum of the input maximums */
        
        public double maxMax()
        {
            return pMaxMax.value();
        }
        
        /** Return the mean of the period maximums */
        
        public double meanMax()
        {
            return pMeanMax.value();
        }
        
        /** Return the median of the period maximums */
        
        public double medianMax()
        {
            return pMedianMax.value();
        }
        
        /** Return the variance of the period maximums */
        
        public double varianceMax()
        {
            return pVarianceMax.value();
        }
        
        /** Return the minimum of the input means */
        
        public double minMean()
        {
            return pMinMean.value();
        }
        
        /** Return the maximum of the input means */
        
        public double maxMean()
        {
            return pMaxMean.value();
        }
        
        /** Return the mean of the input means */
        
        public double meanMean()
        {
            return pMeanMean.value();
        }
        
        /* Return the median of the input medians */
        
        public double medianMean()
        {
            return pMedianMean.value();
        }
        
        /** Return the vairaince of the input means */
        
        public double varianceMean()
        {
            return pVarianceMean.value();
        }
        
        /** Return the minimum of the input medians */
        
        public double minMedian()
        {
            return pMinMedian.value();
        }
        
        /** Return the maximum of the inout medians */
        
        public double maxMedian()
        {
            return pMaxMedian.value();
        }
        
        /** Return the mean of the input medians */
        
        public double meanMedian()
        {
            return pMaxMedian.value();
        }
        
        /** Return the median of the input medians */
        
        public double medianMedian()
        {
            return pMedianMedian.value();
        }
        
        
        /** Return the variance of the input medians */
        
        public double varianceMedian()
        {
            return pVarianceMedian.value();
        }
        
        /** Return the minimum of the input varainces */
        
        public double minVariance()
        {
            return pMinVariance.value
                    ();
        }
        
        /** Return the maximum of thet input variances */
        
        public double maxVariance()
        {
            return pMaxVariance.value();
        }
        
        /** Return the mean of the input variances */
        
        public double meanVariance()
        {
            return pMeanVariance.value();
        }
        
        /** return the median of the input variances */
        
        public double medianVariance()
        {
            return pMedianVariance.value();
        }
        
        /** return the variance of the input variances */
        
        public double varianceVariance()
        {
            return pVarianceVariance.value();
        }
        
        /** return the min of the input skews */
         
        public double minSkew()
        {
            return pMinSkew.value();
        }
        
        /** return the max of the input skew w */
        
        public double maxSkew()
        {
            return pMaxSkew.value();
        }
        
        /** return the max of the input skews */
        
        public double meanSkew()
        {
            return pMeanSkew.value();
        }
        
        /** return the median of the input skews */
        
        public double medianSkew()
        {
            return pMedianSkew.value();
        }
        
        /** return the variances of the input skews */
        
        public double varianceSkew()
        {
            return pVarianceSkew.value();
        }
        
        /*public double minR10_90()
        {
            return pMinR10_90.value();
        }
        
        public double maxR10_90()
        {
            return pMaxR10_90.value();
        }
           
        public double meanR10_90()
        {
            return pMeanR10_90.value();
        }
        
        public double medianR10_90()
        {
            return pMedianR10_90.value();
        }
        
        public double varianceR10_90()
        {
            return pVarianceR10_90.value();
        }
        
        public double minR20_80()
        {
            return pMinR20_80.value();
        }
        
        public double maxR20_80()
        {
            return pMaxR20_80.value();
        }
           
        public double meanR20_80()
        {
            return pMeanR20_80.value();
        }
        
        public double medianR20_80()
        {
            return pMedianR20_80.value();
        }
        
        public double varianceR20_80()
        {
            return pVarianceR20_80.value();
        }
         
        public double minR25_75()
        {
            return pMinR25_75.value();
        }
        
        public double maxR25_75()
        {
            return pMaxR25_75.value();
        }
           
        public double meanR25_75()
        {
            return pMeanR25_75.value();
        }
        
        public double medianR25_75()
        {
            return pMedianR25_75.value();
        }
        
        public double varianceR25_75()
        {
            return pVarianceR25_75.value();
        }
        
        public double minS10_90()
        {
            return pMinS10_90.value();
        }
        
        public double maxS10_90()
        {
            return pMaxS10_90.value();
        }
           
        public double meanS10_90()
        {
            return pMeanS10_90.value();
        }
        
        public double medianS10_90()
        {
            return pMedianS10_90.value();
        }
        
        public double varianceS10_90()
        {
            return pVarianceS10_90.value();
        }
        
        public double minS20_80()
        {
            return pMinS20_80.value();
        }
        
        public double maxS20_80()
        {
            return pMaxS20_80.value();
        }
           
        public double meanS20_80()
        {
            return pMeanS20_80.value();
        }
        
        public double medianS20_80()
        {
            return pMedianS20_80.value();
        }
        
        public double varianceS20_80()
        {
            return pVarianceS20_80.value();
        }
        
        public double minS25_75()
        {
            return pMinS25_75.value();
        }
        
        public double maxS25_75()
        {
            return pMaxS25_75.value();
        }
           
        public double meanS25_75()
        {
            return pMeanS25_75.value();
        }
        
        public double medianS25_75()
        {
            return pMedianS25_75.value();
        }
        
        public double varianceS25_75()
        {
            return pVarianceS25_75.value();
        }*/
        
        /** Return the min of the input number of highpulses */
        
        public double minNumHighPulses()
        {
            return pMinNumHighPulses.value();
        }
        
        /** Return the max of the input number of high pulses */
        
        public double maxNumHighPulses()
        {
            return pMaxNumHighPulses.value();
        }
        
        /** Return the mean of the input number of high pulses */
        
        public double meanNumHighPulses()
        {
            return pMeanNumHighPulses.value();
        }
        
        /** Return the median of the input number of high pulses */
        
        public double medianNumHighPulses()
        {
            return pMedianNumHighPulses.value();
        }
        
        /** Return the variance of the input number of high pulses */
        
        public double varianceNumHighPulses()
        {
            return pVarianceNumHighPulses.value();
        }
        
        /** Return the min of the input high pulses durations */
        
        public double minHighPulseDur()
        {
            return pMinHighPulseDur.value();
        }
        
        /** Return the max of the input high pulse durations */
        
        public double maxHighPulseDur()
        {
            return pMaxHighPulseDur.value();
        }
        
        /** Return the mean of the input high pulse duratiions */
        
        public double meanHighPulseDur()
        {
            return pMeanHighPulseDur.value();
        }
        
        /** Return the median of the input high pulse durations */
        
        public double medianHighPulseDur()
        {
            return pMedianHighPulseDur.value();
        }
        
        /** Return the variance of the input high pulse durations */
        
        public double varianceHighPulseDuration()
        {
            return pVarianceHighPulseDur.value();
        }
        
        /** Return the min of the input number of low pulses */
         
        public double minNumLowPulses()
        {
            return pMinNumLowPulses.value();
        }
        
        /** return the max of the input number of low pulses */
        
        public double maxNumLowPulses()
        {
            return pMaxNumLowPulses.value();
        }
        
        /** Return the mean of the input number of low pulses */
        
        public double meanNumLowPulses()
        {
            return pMeanNumLowPulses.value();
        }
        
        /** Return the median of the input number of low pulses */
        
        public double medianNumLowPulses()
        {
            return pMedianNumLowPulses.value();
        }
        
        /** return the variance of the input number of low pulses */
        
        public double varianceNumLowPulses()
        {
            return pVarianceNumHighPulses.value();
        }
        
        /** Return the minimum of the input low pulse durations */
        
        public double minLowPulseDur()
        {
            return pMinLowPulseDur.value();
        }
        
        /** Return the maximum of the input low pulse durations */
        
        public double maxLowPulseDur()
        {
            return pMaxLowPulseDur.value();
        }
        
        /** Return the mean of the input low pulse durations */
        
        public double meanLowPulseDur()
        {
            return pMeanLowPulseDur.value();
        }
        
        /** Return the median of the input low pulse durations */
        
        public double medianLowPulseDur()
        {
            return pMedianLowPulseDur.value();
        }
        
        /** Return the variance of the input low pulse durations */
        
        public double varianceLowPulseDuration()
        {
            return pVarianceLowPulseDur.value();
        }
        
        /** Return the minimum of the input number of rising days */
        
        public double minNumRises()
        {
            return pMinNumRises.value();
        }
        
        /** Return the maximum of the input number of rising days */
        
        public double maxNumRises()
        {
            return pMaxNumRises.value();
        }
        
        /** Return the mean of the input number of rising days */
        
        public double meanNumRises()
        {
            return pMeanNumRises.value();
        }
        
        /** Return the median of the input number of rising days */
        
        public double medianNumRises()
        {
            return pMedianNumRises.value();
        }
        
        /** Return the variance of the input number of rising days */
        
        public double varianceNumRises()
        {
            return pVarianceNumRises.value();
        }
        
        /** Return the minimum of the input mean rises */
        
        public double minMeanRise()
        {
            return pMinMeanRise.value();
        }
        
        /** Return the maximum of the input mean rises */
        
        public double maxMeanRise()
        {
            return pMaxMeanRise.value();
        }       
        
        /** Return the mean of the input mean rises */
        
        public double meanMeanRise()
        {
            return pMeanMeanRise.value();
        }
        
        /** Return the median of the input mean rises */
        
        public double medianMeanRise()
        {
            return pMedianMeanRise.value();
        }
        
        /** Return the variance of the input mean rises */
        
        public double varianceMeanRise()
        {
            return pVarianceMeanRise.value();
        }
        
        /** Return the minimum of the input number of falling days */
        
        public double minNumFalls()
        {
            return pMinNumFalls.value();
        }
        
        /** Return the maximum of the input number of falling days */
        
        public double maxNumFalls()
        {
            return pMaxNumFalls.value();
        }
        
        /** Return the mean of the input number of falling days */
        
        public double meanNumFalls()
        {
            return pMeanNumFalls.value();
        }
        
        /** Return the median of the input number of falling days */
        
        public double medianNumFalls()
        {
            return pMedianNumFalls.value();
        }
        
        /** Return the variance of the input number of falling days */
        
        public double varianceNumFalls()
        {
            return pVarianceNumFalls.value();
        }
        
        /** Return the minimum of the input mean falls */
        
        public double minMeanFall()
        {
            return pMinMeanFall.value();
        }
        
        /** Return the maximum of the input mean falls */
        
        public double maxMeanFall()
        {
            return pMaxMeanFall.value();
        }       
        
        /** Return the mean of the input mean falls */
        
        public double meanMeanFall()
        {
            return pMeanMeanFall.value();
        }
        
        /** Return the median of the input mean falls */
        
        public double medianMeanFall()
        {
            return pMedianMeanFall.value();
        }
        
        /** Return the variance of the input mean falls */
        
        public double varianceMeanFall()
        {
            return pVarianceMeanFall.value();
        }
        
        /** initalize the member variables */
        
        private void init()
        {
            pData = null;
            
            pMinMin = new HecDouble(0.0);
            pMaxMin = new HecDouble(0.0);
            pMeanMin = new HecDouble(0.0);
            pMedianMin = new HecDouble(0.0);
            pVarianceMin = new HecDouble(0.0);            
            
            pMinMax = new HecDouble(0.0);
            pMaxMax = new HecDouble(0.0);
            pMeanMax = new HecDouble(0.0);
            pMedianMax = new HecDouble(0.0);
            pVarianceMax = new HecDouble(0.0);         
            
            pMinMean = new HecDouble(0.0);
            pMaxMean = new HecDouble(0.0);
            pMeanMean = new HecDouble(0.0);
            pMedianMean = new HecDouble(0.0);
            pVarianceMean = new HecDouble(0.0);
        
            // median stats
            pMinMedian= new HecDouble(0.0);
            pMaxMedian= new HecDouble(0.0);
            pMeanMedian= new HecDouble(0.0);
            pMedianMedian = new HecDouble(0.0);
            pVarianceMedian = new HecDouble(0.0);
        
            // variance stats
             pMinVariance = new HecDouble(0.0);
             pMaxVariance = new HecDouble(0.0);
             pMeanVariance = new HecDouble(0.0);
             pMedianVariance = new HecDouble(0.0);
             pVarianceVariance = new HecDouble(0.0);

            // skew stats
             pMinSkew = new HecDouble(0.0);
             pMaxSkew = new HecDouble(0.0);
             pMeanSkew = new HecDouble(0.0);
             pMedianSkew = new HecDouble(0.0);
             pVarianceSkew = new HecDouble(0.0);
             
             /*// r10_90 stats
             pMinR10_90 = new HecDouble(0.0);
             pMaxR10_90 = new HecDouble(0.0);
             pMeanR10_90 = new HecDouble(0.0);
             pMedianR10_90 = new HecDouble(0.0);
             pVarianceR10_90 = new HecDouble(0.0);
             
             // r20_80 stats
             pMinR20_80 = new HecDouble(0.0);
             pMaxR20_80 = new HecDouble(0.0);
             pMeanR20_80 = new HecDouble(0.0);
             pMedianR20_80 = new HecDouble(0.0);
             pVarianceR20_80 = new HecDouble(0.0);;
             
             // r25_78 stats
             pMinR25_75 = new HecDouble(0.0);
             pMaxR25_75 = new HecDouble(0.0);
             pMeanR25_75 = new HecDouble(0.0);
             pMedianR25_75 = new HecDouble(0.0);
             pVarianceR25_75 = new HecDouble(0.0);

            // s10_90 stats
             pMinS10_90 = new HecDouble(0.0);
             pMaxS10_90 = new HecDouble(0.0);
             pMeanS10_90 = new HecDouble(0.0);
             pMedianS10_90 = new HecDouble(0.0);
             pVarianceS10_90 = new HecDouble(0.0);

             // s20_80 stats
             pMinS20_80 = new HecDouble(0.0);
             pMaxS20_80 = new HecDouble(0.0);
             pMeanS20_80 = new HecDouble(0.0);
             pMedianS20_80 = new HecDouble(0.0);
             pVarianceS20_80 = new HecDouble(0.0);
             
             // s25_78 stats
             pMinS25_75 = new HecDouble(0.0);
             pMaxS25_75 = new HecDouble(0.0);
             pMeanS25_75 = new HecDouble(0.0);
             pMedianS25_75 = new HecDouble(0.0);
             pVarianceS25_75 = new HecDouble(0.0);*/
             
             // Num High Pulses stats
             
             pMinNumHighPulses = new HecDouble(0.0);
             pMaxNumHighPulses = new HecDouble(0.0);
             pMeanNumHighPulses = new HecDouble(0.0);
             pMedianNumHighPulses = new HecDouble(0.0);
             pVarianceNumHighPulses = new HecDouble(0.0);
             
             // High Pulse Duration stats
             
             pMinHighPulseDur = new HecDouble(0.0);
             pMaxHighPulseDur = new HecDouble(0.0);
             pMeanHighPulseDur = new HecDouble(0.0);
             pMedianHighPulseDur = new HecDouble(0.0);
             pVarianceHighPulseDur = new HecDouble(0.0);             
             
             // Num Low Pulses stats
             
             pMinNumLowPulses = new HecDouble(0.0);
             pMaxNumLowPulses = new HecDouble(0.0);
             pMeanNumLowPulses = new HecDouble(0.0);
             pMedianNumLowPulses = new HecDouble(0.0);
             pVarianceNumLowPulses = new HecDouble(0.0);
             
             // Low Pulse Duration stats
             
             pMinLowPulseDur = new HecDouble(0.0);
             pMaxLowPulseDur = new HecDouble(0.0);
             pMeanLowPulseDur = new HecDouble(0.0);
             pMedianLowPulseDur = new HecDouble(0.0);
             pVarianceLowPulseDur = new HecDouble(0.0);
             
             // Rising Day Stats
             
             pMinNumRises = new HecDouble(0.0);
             pMaxNumRises = new HecDouble(0.0);
             pMeanNumRises = new HecDouble(0.0);
             pMedianNumRises = new HecDouble(0.0);
             pVarianceNumRises = new HecDouble(0.0);
             
             // Mean Rise Stats
             
             pMinMeanRise = new HecDouble(0.0);
             pMaxMeanRise = new HecDouble(0.0);
             pMeanMeanRise = new HecDouble(0.0);
             pMedianMeanRise = new HecDouble(0.0);
             pVarianceMeanRise = new HecDouble(0.0);
             
             // Falling Day Stats
             
             pMinNumFalls = new HecDouble(0.0);
             pMaxNumFalls = new HecDouble(0.0);
             pMeanNumFalls = new HecDouble(0.0);
             pMedianNumFalls = new HecDouble(0.0);
             pVarianceNumFalls = new HecDouble(0.0);
             
             // Mean Rise Stats
             
             pMinMeanFall = new HecDouble(0.0);
             pMaxMeanFall = new HecDouble(0.0);
             pMeanMeanFall = new HecDouble(0.0);
             pMedianMeanFall = new HecDouble(0.0);
             pVarianceMeanFall = new HecDouble(0.0);             
        }
        
        /** Calculate agregate statistics for the data set.
         *  Each type of data is extracted into an array, then
         *  the mean, min, max and median are found */
        
        private void calcStats()
        {
            int n = pData.size();
            double[] data = new double[n];
            
            // get min stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).min();
            }
            
            arrayStats(data,pMinMin,pMaxMin,pMeanMin,pMedianMin,pVarianceMin);          
                   
            // get mean stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).max();
            }
            
            arrayStats(data,pMinMax,pMaxMax,pMeanMax,pMedianMax,pVarianceMax);          
                   
            // get mean stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).mean();
            }
            
            arrayStats(data,pMinMean,pMaxMean,pMeanMean,pMedianMean,pVarianceMean);          
            
            // get median stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).median();
            }
            
            arrayStats(data,pMinMedian,pMaxMedian,pMeanMedian,pMedianMedian,pVarianceMedian);
                            
            // get variance stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).variance();
            }
            
            arrayStats(data,pMinVariance,pMaxVariance,pMeanVariance,pMedianVariance,pVarianceVariance);
                        
            // get skew stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).skew();
            }
            
            arrayStats(data,pMinSkew,pMaxSkew,pMeanSkew,pMedianSkew,pVarianceSkew);
                               
            /* // get R10_90 stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).rangeRatio(.10,.90);
            }
            
            arrayStats(data,pMinR10_90,pMaxR10_90,pMeanR10_90,pMedianR10_90,pVarianceR10_90);
            
            // get R20_80 stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).rangeRatio(.20,.80);
            }
            
            arrayStats(data,pMinR20_80,pMaxR20_80,pMeanR20_80,pMedianR20_80,pVarianceR20_80);
            
            // get R25_75 stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).rangeRatio(.25,.75);
            }
            
            arrayStats(data,pMinR25_75,pMaxR25_75,pMeanR25_75,pMedianR25_75,pVarianceR25_75);
                               
            // get S10_90 stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).spreadRatio(.10,.90);
            }
            
            arrayStats(data,pMinS10_90,pMaxS10_90,pMeanS10_90,pMedianS10_90,pVarianceS10_90);
            
            // get R20_80 stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).spreadRatio(.20,.80);
            }
            
            arrayStats(data,pMinS20_80,pMaxS20_80,pMeanS20_80,pMedianS20_80,pVarianceS20_80);
            
            // get R25_75 stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).spreadRatio(.25,.75);
            }
            
            arrayStats(data,pMinS25_75,pMaxS25_75,pMeanS25_75,pMedianS25_75,pVarianceS25_75); */
            
             // get Number High Pulse stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).highPulses();
            }
            
            arrayStats(data,pMinNumHighPulses,pMaxNumHighPulses,pMeanNumHighPulses,pMedianNumHighPulses,pVarianceNumHighPulses);
            
             // get High Pulse Duration stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).averageHighPulseDuration();
            }
            
            arrayStats(data,pMinHighPulseDur,pMaxHighPulseDur,pMeanHighPulseDur,pMedianHighPulseDur,pVarianceHighPulseDur);            
            
             // get Number Low Pulse stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).lowPulses();
            }
            
            arrayStats(data,pMinNumLowPulses,pMaxNumLowPulses,pMeanNumLowPulses,pMedianNumLowPulses,pVarianceNumLowPulses);
            
             // get High Pulse Duration stats
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).averageLowPulseDuration();
            }
            
            arrayStats(data,pMinLowPulseDur,pMaxLowPulseDur,pMeanLowPulseDur,pMedianLowPulseDur,pVarianceLowPulseDur); 
            
             // get Number of Rising Days
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).numRises();
            }
            
            arrayStats(data,pMinNumRises,pMaxNumRises,pMeanNumRises,pMedianNumRises,pVarianceNumRises);
             
             // get Mean Rise amount
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).averageRiseAmount();
            }
            
            arrayStats(data,pMinMeanRise,pMaxMeanRise,pMeanMeanRise,pMedianMeanRise,pVarianceMeanRise);           
            
             // get Number of Falling Days
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).numFalls();
            }
            
            arrayStats(data,pMinNumFalls,pMaxNumFalls,pMeanNumFalls,pMedianNumFalls,pVarianceNumFalls);
             
             // get Mean Rise amount
            for(int i = 0; i < n; ++i)
            {
                data[i] = pData.get(i).averageFallAmount();
            }
            
            arrayStats(data,pMinMeanFall,pMaxMeanFall,pMeanMeanFall,pMedianMeanFall,pVarianceMeanFall);              
            
        }
        
        /**  Find the min, max, mean, and median of the input array. The results
         *  are stored in the input variables */
        
        private void arrayStats(double[] data, HecDouble min, HecDouble max, HecDouble mean, HecDouble median, HecDouble variance)
        {
            java.util.Arrays.sort(data);
            
            int n = data.length;
            
            min.set(data[0]);
            max.set(data[n-1]);
            
            if ( n % 2 == 1 )
            {
                median.set(data[n/2]);
            }
            else
            {
                n /= 2;
                median.set((data[n-1] + data[n]) / 2);
            }
            
            mean.set(0.0);
            for(int i = 0; i < n; ++i)
            {
                mean.add(data[i]);
            }
            mean.divide(n);
            
            variance.set(0.0);
            for(int i = 0; i < n; ++i)
            {
                double val = data[i] - mean.value();
                val *= val;
                variance.add(val);
            }
            variance.divide(n-1);
            
        }
        
        // member variables
        
        /** Array that holds the input data sets */
        private ArrayList<VarStatDataExt> pData;
        
        // min stats
        /** The min of input mins */
        private HecDouble pMinMin;
        /** The max of input mins */
        private HecDouble pMaxMin;
        /** The mean of input mins */
        private HecDouble pMeanMin;
        /** The median of input mins */
        private HecDouble pMedianMin;
        /** The variance of input mins */
        private HecDouble pVarianceMin;
        
        //max stats
        /** The min of inputs maxs */
        private HecDouble pMinMax;
        /** The max of input maxs */
        private HecDouble pMaxMax;
        /** The mean of the maxs */
        private HecDouble pMeanMax;
        /** The median of the maxs */
        private HecDouble pMedianMax;
        /** The variance of the maxs */
        private HecDouble pVarianceMax;        
        
        // mean stats
        /** The min of the means */
        private HecDouble pMinMean;
        /** The max of the means */
        private HecDouble pMaxMean;
        /** The mean of the means */
        private HecDouble pMeanMean;
        /** The median of the means */
        private HecDouble pMedianMean;
        /** The variance of the means */
        private HecDouble pVarianceMean;
        
        // median stats
        /** The min of the medians */
        private HecDouble pMinMedian;
        /** The max of the medians */
        private HecDouble pMaxMedian;
        /** The mean of the medians */
        private HecDouble pMeanMedian;
        /** The median of the medians */
        private HecDouble pMedianMedian;
        /** The variance of the medians */
        private HecDouble pVarianceMedian;
        
        // variance stats
        /** The min of the variances */
        private HecDouble pMinVariance;
        /** The max of the variances */
        private HecDouble pMaxVariance;
        /** The mean of the variances */
        private HecDouble pMeanVariance;
        /** The median of the variances */
        private HecDouble pMedianVariance;
        /** The variance of the variances */
        private HecDouble pVarianceVariance;
        
        // skew stats
        /** The min of the skews */
        private HecDouble pMinSkew;
        /** The max of the skews */
        private HecDouble pMaxSkew;
        /** The mean of the skews */
        private HecDouble pMeanSkew;
        /** The median of the skews */
        private HecDouble pMedianSkew;
        /** The variance of the skews */
        private HecDouble pVarianceSkew;
        
        /*// r10_90 stats
        private HecDouble pMinR10_90;
        private HecDouble pMaxR10_90;
        private HecDouble pMeanR10_90;
        private HecDouble pMedianR10_90;
        private HecDouble pVarianceR10_90;
        
         // r20_80 stats
        private HecDouble pMinR20_80;
        private HecDouble pMaxR20_80;
        private HecDouble pMeanR20_80;
        private HecDouble pMedianR20_80;
        private HecDouble pVarianceR20_80;
        
         // r25_78 stats
        private HecDouble pMinR25_75;
        private HecDouble pMaxR25_75;
        private HecDouble pMeanR25_75;
        private HecDouble pMedianR25_75;
        private HecDouble pVarianceR25_75;
             
        // s10_90 stats
        private HecDouble pMinS10_90;
        private HecDouble pMaxS10_90;
        private HecDouble pMeanS10_90;
        private HecDouble pMedianS10_90;
        private HecDouble pVarianceS10_90;
        
         // s20_80 stats
        private HecDouble pMinS20_80;
        private HecDouble pMaxS20_80;
        private HecDouble pMeanS20_80;
        private HecDouble pMedianS20_80;
        private HecDouble pVarianceS20_80;
        
         // s25_78 stats
        private HecDouble pMinS25_75;
        private HecDouble pMaxS25_75;
        private HecDouble pMeanS25_75;
        private HecDouble pMedianS25_75;
        private HecDouble pVarianceS25_75;*/
        
        // Number of High Pulses
        /** The min of the high pulse counts */
        private HecDouble pMinNumHighPulses;
        /** The max of the high pulse counts */
        private HecDouble pMaxNumHighPulses;
        /** The mean of the high pulse counts */
        private HecDouble pMeanNumHighPulses;
        /** The median of the high pulse counts */
        private HecDouble pMedianNumHighPulses;
        /** The variance of the high pulse counts */
        private HecDouble pVarianceNumHighPulses;
        
        // Duration of High Pulses
        /** The min of the high pulse durations */
        private HecDouble pMaxHighPulseDur;
        /** The max of the high pulse durations */
        private HecDouble pMinHighPulseDur;
        /** The mean of the high pulse durations */
        private HecDouble pMeanHighPulseDur;
        /** The median of the high pulse durations */
        private HecDouble pMedianHighPulseDur;
        /** The variance of the high pulse durations */
        private HecDouble pVarianceHighPulseDur;
        
        // Number of Low Pulses
        /** The min of the low pulse counts */
        private HecDouble pMinNumLowPulses;
        /** The max of the low pulse counts */
        private HecDouble pMaxNumLowPulses;
        /** The mean of the low pulse counts */
        private HecDouble pMeanNumLowPulses;
        /** The median of the low pulse counts */
        private HecDouble pMedianNumLowPulses;
        /** The variance of the low pulse counts */
        private HecDouble pVarianceNumLowPulses;
        
        // Duration of Low Pulses
        /** The min of the high pulse durations */
        private HecDouble pMaxLowPulseDur;
        /** The max of the high pulse durations */
        private HecDouble pMinLowPulseDur;
        /** The mean of the high pulse durations */
        private HecDouble pMeanLowPulseDur;
        /** The median of the high pulse durations */
        private HecDouble pMedianLowPulseDur;
        /** The variance of the high pulse durations */
        private HecDouble pVarianceLowPulseDur;
        
        // Number of Rising Days
        /** The min of the rising days */
        private HecDouble pMinNumRises;
        /** The max of the rising days */
        private HecDouble pMaxNumRises;
        /** The mean of the rising days */
        private HecDouble pMeanNumRises;
        /** The median of the rising days */
        private HecDouble pMedianNumRises;
        /** The variance of the rising days */
        private HecDouble pVarianceNumRises;
        
         // Average Rise
        /** The min of the average rises */
        private HecDouble pMinMeanRise;
        /** The max of the average rises */
        private HecDouble pMaxMeanRise;
        /** The mean of the average rises */
        private HecDouble pMeanMeanRise;
        /** The median of the average rises */
        private HecDouble pMedianMeanRise;
        /** The variance of the average rises */
        private HecDouble pVarianceMeanRise;       
        
        // Number of Falling Days
        /** The min of the falling days */
        private HecDouble pMinNumFalls;
        /** The max of the falling days */
        private HecDouble pMaxNumFalls;
        /** The mean of the falling days */
        private HecDouble pMeanNumFalls;
        /** The median of the falling days */
        private HecDouble pMedianNumFalls;
        /** The variance of the falling days */
        private HecDouble pVarianceNumFalls;
        
         // Average Rise
        /** The min of the average falls */
        private HecDouble pMinMeanFall;
        /** The max of the average falls */
        private HecDouble pMaxMeanFall;
        /** The mean of the average falls */
        private HecDouble pMeanMeanFall;
        /** The median of the average falls */
        private HecDouble pMedianMeanFall;
        /** The variance of the average falls */
        private HecDouble pVarianceMeanFall;           
        
        
    }
    
    // HEC varaiables
    
    /** Object for reading timeseries data from a DSS file */
    //private HecTimeSeries ts;
    
    /** The dates associated with the currenty read of data */
    private HecTimeArray days;
    
    /** The stages associated with the currenty read of data */
    private HecDoubleArray values;
    
    /** The start time for the current DSS read */
    private HecTime startTime;
    
    /** The end time for the current DSS read */
    private HecTime stopTime;
    
    // WetSort Variables
    /** List of the durations to calculate wetsort values for */
    private ArrayList<Double> durations;
    
    /** the number of days required for each duration */
    private ArrayList<Long> duration_length;
    
    /** Array holding the wetsort data for each year */
    private ArrayList< ArrayList<YearData> > data;
    
    /** Array holding the median wetsort value for each duration */
    private ArrayList<HecDouble> median_val;
    
    /** Array hodling the mean wetsort value for each duration */
    private ArrayList<HecDouble> mean_val;
    
    /** Array holding the standard deviation of the wetsort value for each duration */
    private ArrayList<HecDouble> std_val;
    
    /** Array hodling the mean differnce between the wetsort value for each year and the 
     *  max value in the wetsort values time window */
    private ArrayList<HecDouble> diff_val;
    
    /** menu item that allows the addition of custom items */
    private ArrayList<javax.swing.JMenuItem> customDuration;
    
    /** Flag that indacts the differnce between the wetsort value and the max value
     *  of its window is to be show */
    private boolean calcDiff;
    
    /** Flag indicating wither to show the standard deviation of the wetsort values */
    private boolean calcStd;
    
    /** Flag indicating wither to show the mean of the wetsort values */
    private boolean calcMean;
    
    /** Flag indicating wither to show the median of the wetsort values */
    private boolean calcMedian;
    
    /** Flag indicating wither to show the yearly wetsort values */
    private boolean showYearData;
 
    /** The first year to calculate values for stored as a String */
    private String windowStart;
    
    /** The last year to calculate values for stored as a String */
    private String windowStop;
    
    // Variability Stats Variables
    
    /** Array that holds the stat data for each year */
    private ArrayList<VarStatDataExt> vsData;
    
    /** Holds summary stats for the yearly data */
    private VarStatSummaryData vsSummary;
    
    /** Acumulates the yearly stages */
    private ArrayList<Double> vsStages;
    
    /** Holds stats for the period of record */
    private VarStatData vsStagesStats;
    
    /* vsc -- variabilty stat calc <statistic to display>.*/
    
    /** Flag that derermins if yearly min stats are to be displayed */
    private boolean vscMin;
    
    /** Flag that derermins if yearly min stats are to be displayed */
    private boolean vscMax;
    
    /** Flag that determins if yearly means and mean stats are displayed.*/
    private boolean vscMean;
    
    /** Flag that determins if yearly medians and median stats are displayed.*/
    private boolean vscMedian;
    
    /** Flag that determins if yearly variance and variance stats are displayed. */
    private boolean vscVariance;
    
     /** Flag that determins if yearly skews and skew stats are displayed. */
    private boolean vscSkew;
    
    /** Flag that determins if range ratios are displayed for the period of record. */
    private boolean vscRange;
    
    /** flag that determins if spread ratios are displayed for the period of record. */
    private boolean vscSpread;
    
    /** flag that determins if yearly high pulse count and high pulse count stats are displayed. */
    private boolean vscHighPulseCount;
    
    /** flag that determins if yearly high pulse count average durations and average high pulse 
     *  duration stats are displayed. */
    private boolean vscHighPulseDur;
    
    /** Flag that determins if yearly low pulse count and low pulse count stats are displayed */
    private boolean vscLowPulseCount;
    
    /** Flag that determins if yearly low pulse count average durations and average low pulse 
     *  duration stats are displayed. */    
    private boolean vscLowPulseDur;
    
    /* Flag that determins if the yearly number of rising days and rising day stats are shown. */
    private boolean vscNumRises;
    
    /** Flag that determines if the yearly mean rise and mean rise stats are shown. */
    private boolean vscMeanRise;
    
    /** Flag that determins if the yearly number of falling days and falling day stats are shown. */
    private boolean vscNumFalls;
    
    /** Flag that determines if the yearly mean fall and mean fall stats are shown. */
    private boolean vscMeanFall;
            
    
    // Program variables
    
    /** The first year in the selected path to read data from. */
    private String startYear;
    
    /** The last year in the select path to read data from. */
    private String stopYear;
    
    /** The number of years of data that will be processed */
    private int numYears;
    
    private int currentIndex;
    
    /** The current DSS path */
    private String currentPath;
    
    private ArrayList<String> selectedPaths;
    
 
    // IO variables
    /** The last DSS File opened */
    private java.io.File lastFile;
    
    /** Flag indicating if a DSS File has been loaded. */
    private boolean fileLoaded;
    
    // Table variables
    /** Model for the DSS path display table. */
    private javax.swing.table.DefaultTableModel pathTableModel;
    
    // application preferences
    
    /** Preference object for the class */
    private Preferences prefs;
    
    /** The output directory path. */
    private String outputDirPath;
    
    /** The first day in a year to read data for. */
    private int seasonStartDay;
    
    /** The first month in a year to read data for */
    private int seasonStartMonth;
    
    /** The last day in the year to read data for */
    private int seasonStopDay;
    
    /** The last day in the year to read data for */
    private int seasonStopMonth;
    
    // number formaters
    private javax.swing.text.MaskFormatter yf1;
    private javax.swing.text.MaskFormatter yf2;
    
    /** dialog to query for a custum duration value */
    private CustomDurationDialog durationDialog;
    
    /** Indication of the current program mode */
    private int mode;
    
    final int WETSORT = 1;
    final int VARSTATS = 2;
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu JModeMenu;
    private javax.swing.JMenuItem jAddDurationMenuItem;
    private javax.swing.JCheckBox jAdditionalCheckBox;
    private javax.swing.JPanel jBottomPanel;
    private javax.swing.JTextField jDSSFilename;
    private javax.swing.JCheckBoxMenuItem jDefualtDuration1Item;
    private javax.swing.JCheckBoxMenuItem jDefualtDuration2Item;
    private javax.swing.JCheckBoxMenuItem jDefualtDuration3Item;
    private javax.swing.JCheckBoxMenuItem jDefualtDuration4Item;
    private javax.swing.JCheckBoxMenuItem jDefualtDuration5Item;
    private javax.swing.JCheckBox jDiffElevCheckBox;
    private javax.swing.JButton jDssFileBrowseButton;
    private javax.swing.JMenu jDurationMenu;
    private javax.swing.JPanel jDurationPanel;
    private javax.swing.JMenu jFileMenu;
    private javax.swing.JPanel jFilePanel;
    private javax.swing.JPanel jFileRow1Panel;
    private javax.swing.JPanel jFileRow2Panel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JCheckBox jMaxCheckBox;
    private javax.swing.JCheckBox jMeanElevCheckBox;
    private javax.swing.JCheckBox jMeanFallCheckBox;
    private javax.swing.JCheckBox jMeanHPDurCheckBox;
    private javax.swing.JCheckBox jMeanLPDurCheckBox;
    private javax.swing.JCheckBox jMeanRiseCheckBox;
    private javax.swing.JCheckBox jMeanStageCheckBox;
    private javax.swing.JCheckBox jMedianElevCheckBox;
    private javax.swing.JCheckBox jMedianStageCheckBox;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JCheckBox jMinCheckBox;
    private javax.swing.JCheckBox jNumFallsCheckBox;
    private javax.swing.JCheckBox jNumHPCheckBox;
    private javax.swing.JCheckBox jNumLPCheckBox;
    private javax.swing.JCheckBox jNumRisesCheckBox;
    private javax.swing.JMenuItem jOpenMenuItem;
    private javax.swing.JPanel jOptionsPanel;
    private javax.swing.JButton jOutputPathButton;
    private javax.swing.JTextField jOutputPathField;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel10;
    private javax.swing.JPanel jPanel11;
    private javax.swing.JPanel jPanel12;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JPanel jPanel9;
    private javax.swing.JTable jPathTable;
    private javax.swing.JCheckBox jRangeCheckBox;
    private javax.swing.JPanel jRisePanel;
    private javax.swing.JButton jRunButton;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel jSeasonPanel;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JPanel jSpacer1;
    private javax.swing.JPanel jSpacer10;
    private javax.swing.JPanel jSpacer11;
    private javax.swing.JPanel jSpacer12;
    private javax.swing.JPanel jSpacer2;
    private javax.swing.JPanel jSpacer3;
    private javax.swing.JPanel jSpacer4;
    private javax.swing.JPanel jSpacer5;
    private javax.swing.JPanel jSpacer6;
    private javax.swing.JPanel jSpacer7;
    private javax.swing.JPanel jSpacer8;
    private javax.swing.JPanel jSpacer9;
    private javax.swing.JCheckBox jSpreadCheckBox;
    private javax.swing.JCheckBox jStageSkewCheckBox;
    private javax.swing.JCheckBox jStageVarCheckBox;
    private javax.swing.JCheckBox jStandardCheckBox;
    private javax.swing.JCheckBox jStandardDevCheckBox;
    private javax.swing.JLabel jStartTimeLabel;
    private javax.swing.JTextField jStartYearField;
    private javax.swing.JRadioButtonMenuItem jStatsModeItem;
    private javax.swing.JPanel jStatsPanel;
    private javax.swing.JLabel jStopTimeLabel;
    private javax.swing.JTextField jStopYearField;
    private javax.swing.JPanel jTablePanel;
    private javax.swing.JPanel jVarStatsPanel;
    private javax.swing.JRadioButtonMenuItem jWetSortModeItem;
    private javax.swing.JPanel jWetSortPanel;
    private javax.swing.JCheckBox jYearDataCBox;
    private javax.swing.JPanel jYearRangePanel;
    private javax.swing.JPanel jjDailyStagePanel;
    private javax.swing.JPanel jjPulseStatsPanel;
    private wetsort.controls.DateInput startDateInput;
    private wetsort.controls.DateInput stopDateInput;
    // End of variables declaration//GEN-END:variables
    
}
